<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-12T13:31:24.166915Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Data Trend Snapshot</title>
<style>
  :root {
    --bg-light: #fff;
    --bg-dark: #121212;
    --text-light: #000;
    --text-dark: #eee;
    --primary-color: #007acc;
    --border-color-light: #ccc;
    --border-color-dark: #444;
  }
  html {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.4;
    background-color: var(--bg-light);
    color: var(--text-light);
    min-height: 100vh;
  }
  body.dark {
    background-color: var(--bg-dark);
    color: var(--text-dark);
  }
  body, button, select, input {
    font-size: 1rem;
  }
  header {
    padding: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    background-color: var(--primary-color);
    color: white;
  }
  header > * {
    flex: 1 1 auto;
    min-width: 150px;
  }
  label {
    display: inline-block;
  }
  input[type="file"] {
    cursor: pointer;
  }
  button, select {
    background: white;
    border: 1px solid var(--border-color-light);
    border-radius: 4px;
    padding: 0.3em 0.6em;
    cursor: pointer;
    color: var(--text-light);
  }
  body.dark button, body.dark select {
    background: #333;
    border-color: var(--border-color-dark);
    color: var(--text-dark);
  }
  button:focus, select:focus, input[type="file"]:focus {
    outline: 3px solid #ffbf47;
    outline-offset: 2px;
  }
  main {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  #data-table-container {
    overflow-x: auto;
    max-height: 200px;
    border: 1px solid var(--border-color-light);
    border-radius: 4px;
    background: var(--bg-light);
  }
  body.dark #data-table-container {
    background: #222;
    border-color: var(--border-color-dark);
  }
  table {
    border-collapse: collapse;
    width: 100%;
    font-size: 0.9rem;
  }
  th, td {
    border: 1px solid var(--border-color-light);
    padding: 0.3em 0.5em;
    text-align: left;
  }
  body.dark th, body.dark td {
    border-color: var(--border-color-dark);
  }
  th {
    background-color: var(--primary-color);
    color: white;
    position: sticky;
    top: 0;
    z-index: 1;
  }
  #charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(280px,1fr));
    gap: 1rem;
  }
  .chart-region {
    background: var(--bg-light);
    border: 1px solid var(--border-color-light);
    border-radius: 4px;
    padding: 0.5rem;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  body.dark .chart-region {
    background: #222;
    border-color: var(--border-color-dark);
  }
  .chart-region canvas {
    max-width: 100%;
    height: 200px;
  }
  #summary-panel {
    border: 1px solid var(--border-color-light);
    border-radius: 4px;
    padding: 0.5rem;
    background: var(--bg-light);
    overflow-x: auto;
  }
  body.dark #summary-panel {
    background: #222;
    border-color: var(--border-color-dark);
  }
  #summary-panel table {
    width: 100%;
    font-size: 0.9rem;
  }
  #summary-panel th {
    background-color: var(--primary-color);
    color: white;
  }
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
  }
  #column-selector {
    min-width: 200px;
  }
  @media print {
    body {
      background: white !important;
      color: black !important;
    }
    header, #controls {
      display: none !important;
    }
    .chart-region {
      border: none !important;
      background: none !important;
      padding: 0 !important;
      page-break-inside: avoid;
    }
    canvas {
      max-width: 100% !important;
      height: auto !important;
      filter: grayscale(100%) contrast(120%);
    }
    #summary-panel {
      border: none !important;
      background: none !important;
      padding: 0 !important;
    }
  }
</style>
</head>
<body>
<header role="banner" aria-label="Application controls">
  <label for="file-input">Upload CSV or JSON file</label>
  <input type="file" id="file-input" aria-describedby="file-desc" accept=".csv,application/json,text/json" />
  <span id="file-desc" class="sr-only">Select a CSV or JSON file to upload and visualize data</span>

  <label for="column-selector">Select columns to visualize</label>
  <select id="column-selector" multiple aria-label="Select columns to visualize" size="4" disabled></select>

  <button id="theme-toggle" aria-pressed="false" aria-label="Toggle dark or light theme">Toggle Dark/Light Theme</button>

  <button id="print-btn" aria-label="Print the dashboard">Print</button>
</header>
<main>
  <section id="data-table-container" role="region" aria-live="polite" aria-label="Parsed data table">
    <table id="data-table" tabindex="0" aria-describedby="data-desc">
      <caption id="data-desc">Parsed data preview</caption>
      <thead><tr></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <section id="summary-panel" role="region" aria-label="Summary statistics panel" tabindex="0">
    <h2>Summary Statistics</h2>
    <table aria-describedby="summary-desc">
      <caption id="summary-desc">Minimum, maximum, and mean values for each numeric column</caption>
      <thead><tr><th>Column</th><th>Min</th><th>Max</th><th>Mean</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <section id="charts-grid" role="region" aria-label="Data visualizations">
    <!-- Charts inserted here -->
  </section>
</main>

<script>
(() => {
  "use strict";

  const fileInput = document.getElementById('file-input');
  const dataTable = document.getElementById('data-table');
  const dataTableHead = dataTable.querySelector('thead tr');
  const dataTableBody = dataTable.querySelector('tbody');
  const columnSelector = document.getElementById('column-selector');
  const chartsGrid = document.getElementById('charts-grid');
  const summaryPanelBody = document.querySelector('#summary-panel tbody');
  const themeToggle = document.getElementById('theme-toggle');
  const printBtn = document.getElementById('print-btn');

  let rawData = [];
  let headers = [];
  let numericColumns = [];
  let selectedColumns = [];
  let charts = [];
  let chartInstances = [];

  // Accessibility helper: screen reader only text
  const srOnlyStyle = 'position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;';

  function setTheme(dark) {
    if(dark) {
      document.body.classList.add('dark');
      themeToggle.setAttribute('aria-pressed', 'true');
      localStorage.setItem('theme', 'dark');
    } else {
      document.body.classList.remove('dark');
      themeToggle.setAttribute('aria-pressed', 'false');
      localStorage.setItem('theme', 'light');
    }
  }

  function detectSystemTheme() {
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  }

  function parseCSV(text) {
    // Simple CSV parser: split by lines, then by commas, trim quotes/spaces
    const lines = text.trim().split(/\r?\n/);
    if(lines.length < 2) return {headers: [], rows: []};
    const hdrs = lines.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    const rows = lines.slice(1).map(line => {
      // Split by commas, respecting quotes (simple)
      const values = [];
      let current = '';
      let inQuotes = false;
      for(let i=0; i<line.length; i++) {
        const c = line[i];
        if(c === '"') {
          inQuotes = !inQuotes;
        } else if(c === ',' && !inQuotes) {
          values.push(current.trim().replace(/^"|"$/g, ''));
          current = '';
        } else {
          current += c;
        }
      }
      values.push(current.trim().replace(/^"|"$/g, ''));
      return values;
    });
    return {headers: hdrs, rows};
  }

  function isNumericColumn(data, colIndex) {
    // Check if at least 80% of values are numeric
    let count = 0;
    let numericCount = 0;
    for(const row of data) {
      if(row[colIndex] !== undefined && row[colIndex] !== '') {
        count++;
        if(!isNaN(parseFloat(row[colIndex]))) numericCount++;
      }
    }
    return count > 0 && (numericCount / count) >= 0.8;
  }

  function computeStats(data, colIndex) {
    const nums = data
      .map(r => parseFloat(r[colIndex]))
      .filter(v => !isNaN(v));
    if(nums.length === 0) return {min: null, max: null, mean: null};
    const min = Math.min(...nums);
    const max = Math.max(...nums);
    const mean = nums.reduce((a,b) => a+b, 0) / nums.length;
    return {min, max, mean};
  }

  function clearCharts() {
    for(const c of chartInstances) {
      c.destroy();
    }
    chartInstances.length = 0;
    chartsGrid.innerHTML = '';
  }

  function createChartRegion(title, chartType, labels, data) {
    const region = document.createElement('section');
    region.className = 'chart-region';
    region.setAttribute('role', 'region');
    region.setAttribute('aria-label', `${chartType} chart for ${title}`);
    region.tabIndex = 0;

    const heading = document.createElement('h3');
    heading.textContent = `${title} (${chartType})`;
    heading.style.margin = '0 0 0.3em 0';
    region.appendChild(heading);

    const canvas = document.createElement('canvas');
    canvas.setAttribute('aria-label', `${chartType} chart for ${title}`);
    canvas.setAttribute('role', 'img');
    region.appendChild(canvas);

    chartsGrid.appendChild(region);

    const chart = new Chart(canvas.getContext('2d'), {
      type: chartType,
      data: {
        labels,
        datasets: [{
          label: title,
          data,
          borderColor: 'rgba(0, 122, 204, 0.8)',
          backgroundColor: chartType === 'bar' ? 'rgba(0, 122, 204, 0.5)' : 'transparent',
          fill: false,
          pointRadius: chartType === 'scatter' ? 5 : 3,
          showLine: chartType !== 'scatter',
          parsing: chartType === 'scatter' ? {xAxisKey: 'x', yAxisKey: 'y'} : false
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
          x: {
            type: chartType === 'scatter' ? 'linear' : 'category',
            title: {display: true, text: 'Index'}
          },
          y: {
            beginAtZero: false,
            title: {display: true, text: title}
          }
        },
        plugins: {
          legend: {display: false},
          tooltip: {enabled: true}
        }
      }
    });
    chartInstances.push(chart);
  }

  function updateCharts() {
    clearCharts();
    if(rawData.length === 0 || selectedColumns.length === 0) return;

    // For each selected numeric column, generate line, bar, scatter charts
    // Use row index as x-axis labels for line and bar
    // For scatter, plot index vs value as points

    const labels = rawData.map((_, i) => i + 1);

    for(const col of selectedColumns) {
      const colIndex = headers.indexOf(col);
      if(colIndex === -1) continue;
      const data = rawData.map(r => {
        const v = parseFloat(r[colIndex]);
        return isNaN(v) ? null : v;
      }).filter(v => v !== null);

      if(data.length === 0) continue;

      createChartRegion(col, 'line', labels, data);
      createChartRegion(col, 'bar', labels, data);

      // Scatter data format [{x: idx, y: val}, ...]
      const scatterData = data.map((v, i) => ({x: i + 1, y: v}));
      createChartRegion(col, 'scatter', null, scatterData);
    }
  }

  function updateSummary() {
    summaryPanelBody.innerHTML = '';
    if(rawData.length === 0) return;
    for(const col of numericColumns) {
      const colIndex = headers.indexOf(col);
      if(colIndex === -1) continue;
      const stats = computeStats(rawData, colIndex);
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${col}</td>
        <td>${stats.min !== null ? stats.min.toFixed(3) : 'N/A'}</td>
        <td>${stats.max !== null ? stats.max.toFixed(3) : 'N/A'}</td>
        <td>${stats.mean !== null ? stats.mean.toFixed(3) : 'N/A'}</td>`;
      summaryPanelBody.appendChild(tr);
    }
  }

  function updateTable() {
    dataTableHead.innerHTML = '';
    dataTableBody.innerHTML = '';
    if(headers.length === 0 || rawData.length === 0) return;

    for(const h of headers) {
      const th = document.createElement('th');
      th.textContent = h;
      dataTableHead.appendChild(th);
    }
    for(const row of rawData) {
      const tr = document.createElement('tr');
      for(const cell of row) {
        const td = document.createElement('td');
        td.textContent = cell;
        tr.appendChild(td);
      }
      dataTableBody.appendChild(tr);
    }
  }

  function updateColumnSelector() {
    columnSelector.innerHTML = '';
    if(numericColumns.length === 0) {
      columnSelector.disabled = true;
      return;
    }
    columnSelector.disabled = false;
    for(const col of numericColumns) {
      const option = document.createElement('option');
      option.value = col;
      option.textContent = col;
      columnSelector.appendChild(option);
    }
    // Restore previously selected columns if any
    if(selectedColumns.length > 0) {
      for(const option of columnSelector.options) {
        option.selected = selectedColumns.includes(option.value);
      }
    } else {
      // Select all numeric columns by default
      for(const option of columnSelector.options) {
        option.selected = true;
      }
      selectedColumns = Array.from(columnSelector.options).map(o => o.value);
    }
  }

  function saveToLocalStorage() {
    try {
      if(rawData.length > 0) {
        const obj = {headers, rawData};
        localStorage.setItem('dts-data', JSON.stringify(obj));
      }
      localStorage.setItem('dts-selected-columns', JSON.stringify(selectedColumns));
    } catch {}
  }

  function loadFromLocalStorage() {
    try {
      const dataStr = localStorage.getItem('dts-data');
      if(dataStr) {
        const obj = JSON.parse(dataStr);
        if(obj.headers && obj.rawData) {
          headers = obj.headers;
          rawData = obj.rawData;
          numericColumns = headers.filter((_, i) => isNumericColumn(rawData, i));
          updateColumnSelector();
          updateTable();
          updateSummary();
          updateCharts();
          // Restore selected columns
          const selColsStr = localStorage.getItem('dts-selected-columns');
          if(selColsStr) {
            const selCols = JSON.parse(selColsStr);
            if(Array.isArray(selCols)) {
              selectedColumns = selCols.filter(c => numericColumns.includes(c));
              for(const option of columnSelector.options) {
                option.selected = selectedColumns.includes(option.value);
              }
              updateCharts();
            }
          }
        }
      }
    } catch {}
  }

  function handleFileLoad(text, type) {
    let parsed;
    if(type === 'json') {
      try {
        const json = JSON.parse(text);
        if(Array.isArray(json) && json.length > 0 && typeof json === 'object') {
          headers = Object.keys(json);
          rawData = json.map(obj => headers.map(h => obj[h] !== undefined ? String(obj[h]) : ''));
        } else {
          alert('JSON must be an array of objects.');
          return;
        }
      } catch {
        alert('Invalid JSON file.');
        return;
      }
    } else {
      // CSV
      parsed = parseCSV(text);
      headers = parsed.headers;
      rawData = parsed.rows;
    }
    numericColumns = headers.filter((_, i) => isNumericColumn(rawData, i));
    selectedColumns = [...numericColumns];
    updateColumnSelector();
    updateTable();
    updateSummary();
    updateCharts();
    saveToLocalStorage();
  }

  fileInput.addEventListener('change', e => {
    const file = e.target.files;
    if(!file) return;
    const ext = file.name.split('.').pop().toLowerCase();
    const reader = new FileReader();
    reader.onload = () => {
      handleFileLoad(reader.result, ext === 'json' ? 'json' : 'csv');
    };
    if(ext === 'json') {
      reader.readAsText(file);
    } else {
      reader.readAsText(file);
    }
  });

  columnSelector.addEventListener('change', () => {
    selectedColumns = Array.from(columnSelector.selectedOptions).map(o => o.value);
    updateCharts();
    saveToLocalStorage();
  });

  themeToggle.addEventListener('click', () => {
    const dark = document.body.classList.contains('dark');
    setTheme(!dark);
  });

  printBtn.addEventListener('click', () => {
    window.print();
  });

  // Initialize theme from localStorage or system preference
  const savedTheme = localStorage.getItem('theme');
  if(savedTheme === 'dark') {
    setTheme(true);
  } else if(savedTheme === 'light') {
    setTheme(false);
  } else {
    setTheme(detectSystemTheme());
  }

  // Load saved data if any
  loadFromLocalStorage();

  // Keyboard navigation: tab order is natural by DOM order
  // ARIA labels added on all interactive elements and chart regions

  // Accessibility: add a style for screen reader only text
  const style = document.createElement('style');
  style.textContent = `.sr-only {${srOnlyStyle}}`;
  document.head.appendChild(style);
})();  
</script>
</body>
</html>