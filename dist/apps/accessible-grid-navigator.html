<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-10-30T19:16:22.869679Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Accessible Grid Navigator</title>
<style>
  :root {
    --focus-outline: 3px solid #005fcc;
    --bg-color: #fff;
    --fg-color: #000;
    --high-contrast-bg: #000;
    --high-contrast-fg: #fff;
    --cell-border: 1px solid #444;
    --cell-padding: 0.3em 0.5em;
    --font-family: Arial, sans-serif;
    --font-size-base: 1rem;
    --font-size-mobile: 1.1rem;
    --font-size-desktop: 1rem;
  }
  body {
    margin: 0;
    font-family: var(--font-family);
    background: var(--bg-color);
    color: var(--fg-color);
    line-height: 1.3;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
  }
  h1 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
  }
  #app {
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  button, input[type="file"] {
    font-size: var(--font-size-base);
    padding: 0.4em 0.8em;
    cursor: pointer;
    border: 2px solid #005fcc;
    background: #e0e8ff;
    color: #003366;
    border-radius: 4px;
    user-select: none;
  }
  button:focus, input[type="file"]:focus {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  #grid-container {
    overflow: auto;
    outline: none;
  }
  [role="grid"] {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(4rem, 1fr));
    gap: 2px;
    border: 2px solid #005fcc;
    border-radius: 4px;
    background: var(--high-contrast-bg);
  }
  [role="grid"][data-print] {
    border: none;
    background: transparent;
    gap: 1px;
  }
  .grid-cell {
    padding: var(--cell-padding);
    border: var(--cell-border);
    background: var(--high-contrast-bg);
    color: var(--high-contrast-fg);
    font-size: var(--font-size-base);
    min-height: 2.5rem;
    display: flex;
    align-items: center;
  }
  .grid-cell[contenteditable="true"] {
    outline-offset: 2px;
    cursor: text;
    user-select: text;
  }
  .grid-cell:focus {
    outline: var(--focus-outline);
    outline-offset: 2px;
    background: #cce4ff;
    color: #000;
  }
  .grid-cell[contenteditable="true"]:focus {
    background: #e6f0ff;
    color: #000;
  }
  #live-region {
    position: absolute;
    left: -9999px;
    width: 1px;
    height: 1px;
    overflow: hidden;
  }
  @media (min-width: 600px) {
    [role="grid"] {
      grid-template-columns: repeat(4, minmax(6rem, 1fr));
    }
    .grid-cell {
      font-size: var(--font-size-desktop);
      min-height: 3rem;
    }
  }
  @media print {
    body {
      background: #fff;
      color: #000;
      padding: 0;
    }
    #controls, #live-region {
      display: none !important;
    }
    #grid-container {
      overflow: visible;
      outline: none;
    }
    [role="grid"] {
      border: none !important;
      grid-template-columns: repeat(4, 1fr) !important;
      gap: 0.5rem !important;
      background: transparent !important;
    }
    .grid-cell {
      border: 1px solid #000 !important;
      background: #fff !important;
      color: #000 !important;
      outline: none !important;
      min-height: 2.5rem;
      padding: 0.2em 0.4em;
      font-size: 0.9rem;
    }
  }
</style>
</head>
<body>
<h1 id="page-title">Accessible Grid Navigator</h1>
<div id="app" role="main">
  <div id="controls" aria-label="Grid controls">
    <button id="btn-export" type="button" aria-label="Export grid content and state as JSON">Export JSON</button>
    <label for="file-import" tabindex="0" role="button" aria-label="Import grid content and state from JSON file" id="label-import" style="border:2px solid #005fcc; padding:0.4em 0.8em; border-radius:4px; background:#e0e8ff; color:#003366; cursor:pointer; user-select:none;">Import JSON
      <input type="file" id="file-import" accept="application/json" style="display:none" aria-hidden="true" />
    </label>
    <button id="btn-toggle-print" type="button" aria-pressed="false" aria-label="Toggle print-friendly view">Toggle Print View</button>
  </div>
  <div id="grid-container" tabindex="0" aria-label="Editable grid container" role="application">
    <div role="grid" aria-rowcount="4" aria-colcount="4" aria-label="Editable grid" id="grid"></div>
  </div>
</div>
<div id="live-region" role="status" aria-live="polite" aria-atomic="true"></div>
<script>
(() => {
  const grid = document.getElementById('grid');
  const liveRegion = document.getElementById('live-region');
  const btnExport = document.getElementById('btn-export');
  const fileImport = document.getElementById('file-import');
  const btnTogglePrint = document.getElementById('btn-toggle-print');
  const gridContainer = document.getElementById('grid-container');

  // Configurable grid size (minimum 4x4)
  const MIN_ROWS = 4;
  const MIN_COLS = 4;

  // State
  let rows = MIN_ROWS;
  let cols = MIN_COLS;
  let cells = []; // 2D array of cell elements
  let focusedCell = {r: 0, c: 0};
  let printView = false;

  // Storage keys
  const STORAGE_KEY = 'accessibleGridNavigatorData';

  // Initialize grid with saved or default data
  function loadFromStorage() {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (!saved) return false;
      const data = JSON.parse(saved);
      if (!data || !data.content || !Array.isArray(data.content)) return false;
      if (data.content.length < MIN_ROWS) return false;
      if (data.content.length < MIN_COLS) return false;
      rows = data.content.length;
      cols = data.content.length;
      return data;
    } catch {
      return false;
    }
  }

  // Save grid content and focus position to localStorage
  function saveToStorage() {
    const content = cells.map(row => row.map(cell => cell.textContent));
    const data = {
      content,
      focus: focusedCell,
      rows,
      cols
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  // Create grid cells and append to grid container
  function createGrid(rCount, cCount, content) {
    grid.innerHTML = '';
    grid.setAttribute('aria-rowcount', rCount);
    grid.setAttribute('aria-colcount', cCount);
    grid.style.gridTemplateColumns = `repeat(${cCount}, minmax(4rem, 1fr))`;
    cells = [];
    for (let r = 0; r < rCount; r++) {
      const rowCells = [];
      for (let c = 0; c < cCount; c++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.setAttribute('role', 'gridcell');
        cell.setAttribute('tabindex', '-1');
        cell.setAttribute('contenteditable', 'true');
        cell.setAttribute('aria-label', `Row ${r + 1} Column ${c + 1}`);
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.textContent = (content && content[r] && content[r][c]) || '';
        rowCells.push(cell);
        grid.appendChild(cell);
      }
      cells.push(rowCells);
    }
  }

  // Focus a cell by row and column indices
  function focusCell(r, c, announce = true) {
    if (r < 0) r = 0;
    if (c < 0) c = 0;
    if (r >= rows) r = rows - 1;
    if (c >= cols) c = cols - 1;
    const cell = cells[r][c];
    if (!cell) return;
    // Remove tabindex from old focused cell
    const oldCell = cells[focusedCell.r]?.[focusedCell.c];
    if (oldCell && oldCell !== cell) {
      oldCell.setAttribute('tabindex', '-1');
    }
    // Set new focused cell tabindex and focus
    cell.setAttribute('tabindex', '0');
    cell.focus();
    focusedCell = {r, c};
    if (announce) announceFocus(cell, r, c);
    saveToStorage();
  }

  // Announce focused cell coordinates and content to screen reader
  function announceFocus(cell, r, c) {
    const content = cell.textContent.trim() || 'empty';
    liveRegion.textContent = `Row ${r + 1} Column ${c + 1}, ${content}`;
  }

  // Handle keyboard navigation inside grid
  function onGridKeyDown(e) {
    const {key, ctrlKey} = e;
    let {r, c} = focusedCell;
    let handled = false;

    switch (key) {
      case 'ArrowUp':
        if (ctrlKey) {
          r = 0;
        } else {
          r--;
        }
        handled = true;
        break;
      case 'ArrowDown':
        if (ctrlKey) {
          r = rows - 1;
        } else {
          r++;
        }
        handled = true;
        break;
      case 'ArrowLeft':
        if (ctrlKey) {
          c = 0;
        } else {
          c--;
        }
        handled = true;
        break;
      case 'ArrowRight':
        if (ctrlKey) {
          c = cols - 1;
        } else {
          c++;
        }
        handled = true;
        break;
      case 'Home':
        if (e.shiftKey) {
          // Shift+Home: move focus to start of row
          c = 0;
        } else {
          // Home: first cell in grid
          r = 0;
          c = 0;
        }
        handled = true;
        break;
      case 'End':
        if (e.shiftKey) {
          // Shift+End: move focus to end of row
          c = cols - 1;
        } else {
          // End: last cell in grid
          r = rows - 1;
          c = cols - 1;
        }
        handled = true;
        break;
      case 'Tab':
        // Let tab move out of grid normally
        return;
    }
    if (handled) {
      e.preventDefault();
      focusCell(r, c);
    }
  }

  // Save content on input or blur
  function onCellInput(e) {
    saveToStorage();
  }

  // On cell focus, announce content and coordinates
  function onCellFocus(e) {
    const cell = e.target;
    if (!cell || !cell.dataset) return;
    const r = parseInt(cell.dataset.row, 10);
    const c = parseInt(cell.dataset.col, 10);
    focusedCell = {r, c};
    announceFocus(cell, r, c);
    saveToStorage();
  }

  // Export grid content and focus state as JSON file
  function exportJSON() {
    const content = cells.map(row => row.map(cell => cell.textContent));
    const data = {
      content,
      focus: focusedCell,
      rows,
      cols
    };
    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'grid-data.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  // Import JSON file and restore grid content and focus
  function importJSON(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (!data || !data.content || !Array.isArray(data.content)) throw new Error('Invalid JSON');
        rows = data.content.length >= MIN_ROWS ? data.content.length : MIN_ROWS;
        cols = data.content.length >= MIN_COLS ? data.content.length : MIN_COLS;
        createGrid(rows, cols, data.content);
        if (data.focus && typeof data.focus.r === 'number' && typeof data.focus.c === 'number') {
          focusedCell = {r: data.focus.r, c: data.focus.c};
        } else {
          focusedCell = {r: 0, c: 0};
        }
        focusCell(focusedCell.r, focusedCell.c, false);
        saveToStorage();
      } catch {
        alert('Failed to load JSON file. Please provide a valid grid JSON.');
      }
    };
    reader.readAsText(file);
  }

  // Toggle print-friendly view
  function togglePrintView() {
    printView = !printView;
    if (printView) {
      grid.setAttribute('data-print', 'true');
      btnTogglePrint.setAttribute('aria-pressed', 'true');
      btnTogglePrint.textContent = 'Exit Print View';
      document.getElementById('controls').style.display = 'none';
    } else {
      grid.removeAttribute('data-print');
      btnTogglePrint.setAttribute('aria-pressed', 'false');
      btnTogglePrint.textContent = 'Toggle Print View';
      document.getElementById('controls').style.display = 'flex';
    }
  }

  // Responsive font size adjustment on resize
  function adjustFontSize() {
    if (window.innerWidth < 600) {
      document.documentElement.style.setProperty('--font-size-base', '1.1rem');
    } else {
      document.documentElement.style.setProperty('--font-size-base', '1rem');
    }
  }

  // Initialize event listeners
  function initEventListeners() {
    grid.addEventListener('keydown', onGridKeyDown);
    grid.addEventListener('focusin', (e) => {
      if (e.target.classList.contains('grid-cell')) onCellFocus(e);
    });
    grid.addEventListener('input', (e) => {
      if (e.target.classList.contains('grid-cell')) onCellInput(e);
    });
    btnExport.addEventListener('click', exportJSON);
    fileImport.addEventListener('change', (e) => {
      if (e.target.files.length) {
        importJSON(e.target.files);
        e.target.value = '';
      }
    });
    btnTogglePrint.addEventListener('click', togglePrintView);
    window.addEventListener('resize', adjustFontSize);
    gridContainer.addEventListener('focus', () => {
      // If no cell focused, focus first cell on container focus
      if (!grid.querySelector('.grid-cell[tabindex="0"]')) {
        focusCell(focusedCell.r, focusedCell.c);
      }
    });
  }

  // Initialization
  function init() {
    adjustFontSize();
    const savedData = loadFromStorage();
    if (savedData) {
      rows = savedData.rows || MIN_ROWS;
      cols = savedData.cols || MIN_COLS;
      createGrid(rows, cols, savedData.content);
      focusedCell = savedData.focus || {r: 0, c: 0};
    } else {
      createGrid(rows, cols);
      focusedCell = {r: 0, c: 0};
    }
    focusCell(focusedCell.r, focusedCell.c, false);
    initEventListeners();
  }

  init();
})();
</script>
</body>
</html>