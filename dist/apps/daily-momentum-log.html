<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-14T13:28:22.766623Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Daily Momentum Log</title>
<style>
  :root {
    --bg-light: #fff;
    --fg-light: #111;
    --bg-dark: #121212;
    --fg-dark: #eee;
    --accent: #007acc;
    --max-width: 70ch;
    --transition: 0.3s ease;
  }
  html {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.5;
    background-color: var(--bg-light);
    color: var(--fg-light);
    transition: background-color var(--transition), color var(--transition);
  }
  html[data-theme="dark"] {
    background-color: var(--bg-dark);
    color: var(--fg-dark);
  }
  body {
    margin: 0;
    padding: 0.5rem 1rem;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    max-width: 100vw;
    min-height: 100vh;
  }
  @media (max-width: 639px) {
    body {
      grid-template-columns: 1fr;
    }
    #history-section {
      display: none;
    }
  }
  h1, h2 {
    margin: 0.5rem 0 0.75rem 0;
    font-weight: 600;
  }
  #app {
    display: flex;
    flex-direction: column;
    max-width: var(--max-width);
    margin: 0 auto;
  }
  #input-form {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }
  #new-entry {
    flex-grow: 1;
    font-size: 1rem;
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: transparent;
    color: inherit;
  }
  #new-entry:focus {
    outline: 2px solid var(--accent);
  }
  button {
    background: var(--accent);
    border: none;
    color: white;
    padding: 0 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
  }
  button:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }
  #day-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  .section {
    border: 1px solid #888;
    border-radius: 6px;
    padding: 0.5rem;
    min-height: 6rem;
    background-color: rgba(0,0,0,0.03);
  }
  html[data-theme="dark"] .section {
    background-color: rgba(255,255,255,0.05);
    border-color: #555;
  }
  .section h2 {
    font-size: 1.1rem;
    border-bottom: 1px solid #888;
    padding-bottom: 0.25rem;
    margin-bottom: 0.5rem;
  }
  html[data-theme="dark"] .section h2 {
    border-color: #555;
  }
  ul.entry-list {
    list-style: none;
    margin: 0;
    padding: 0;
    max-height: 40vh;
    overflow-y: auto;
  }
  ul.entry-list li {
    padding: 0.25rem 0.5rem;
    border-bottom: 1px solid #ccc;
    cursor: grab;
    user-select: none;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 0.95rem;
  }
  html[data-theme="dark"] ul.entry-list li {
    border-color: #444;
  }
  ul.entry-list li:last-child {
    border-bottom: none;
  }
  ul.entry-list li:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }
  #search-section {
    max-width: var(--max-width);
    margin: 0 auto;
    display: flex;
    flex-direction: column;
  }
  #search-input {
    font-size: 1rem;
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid #ccc;
    margin-bottom: 0.75rem;
    background: transparent;
    color: inherit;
  }
  #search-input:focus {
    outline: 2px solid var(--accent);
  }
  #search-results {
    max-height: 80vh;
    overflow-y: auto;
  }
  .search-day {
    margin-bottom: 1rem;
  }
  .search-day h3 {
    margin: 0 0 0.25rem 0;
    font-weight: 600;
    font-size: 1rem;
  }
  .search-day ul {
    list-style: none;
    padding-left: 1rem;
    margin: 0;
  }
  .search-day ul li {
    font-size: 0.9rem;
    padding: 0.15rem 0;
    white-space: pre-wrap;
    word-break: break-word;
  }
  #import-file {
    display: none;
  }
  #import-label {
    background: var(--accent);
    color: white;
    padding: 0.3rem 0.6rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    margin-top: 0.5rem;
    display: inline-block;
  }
  #import-label:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }
</style>
</head>
<body>
<main id="app" role="main" aria-label="Daily Momentum Log application">
  <section id="day-section" aria-label="Current day entries">
    <h1 id="current-date">Loading date...</h1>
    <form id="input-form" aria-label="Add new task or note">
      <label for="new-entry" class="visually-hidden">New entry input</label>
      <textarea id="new-entry" rows="2" aria-multiline="true" aria-describedby="input-instructions" placeholder="Add new task or note..."></textarea>
      <button type="submit" aria-label="Add entry">Add</button>
    </form>
    <div id="day-container" aria-live="polite" aria-relevant="additions removals">
      <section id="pending-section" class="section" aria-label="Pending tasks or notes" tabindex="0">
        <h2>Pending</h2>
        <ul class="entry-list" id="pending-list" role="list" aria-describedby="pending-desc"></ul>
        <p id="pending-desc" class="visually-hidden">List of pending tasks or notes for today. Drag items to Done section to mark as completed.</p>
      </section>
      <section id="done-section" class="section" aria-label="Completed tasks or notes" tabindex="0">
        <h2>Done</h2>
        <ul class="entry-list" id="done-list" role="list" aria-describedby="done-desc"></ul>
        <p id="done-desc" class="visually-hidden">List of completed tasks or notes for today. Drag items to Pending section to mark as not done.</p>
      </section>
    </div>
  </section>
  <section id="history-section" aria-label="Search and historical entries">
    <h2>Search / History</h2>
    <label for="search-input" class="visually-hidden">Search entries</label>
    <input type="search" id="search-input" placeholder="Search entries..." aria-describedby="search-instructions" />
    <p id="search-instructions" class="visually-hidden">Type to search all entries. Use keyboard shortcut Control + F to focus this search box.</p>
    <div id="search-results" role="region" aria-live="polite" aria-atomic="false"></div>
    <button id="export-btn" aria-label="Export all entries as text file">Export .txt</button>
    <label for="import-file" id="import-label" tabindex="0" role="button" aria-label="Import entries from text file">Import .txt</label>
    <input type="file" id="import-file" accept=".txt" aria-hidden="true" />
  </section>
</main>
<script>
  (() => {
    "use strict";

    // Constants
    const STORAGE_KEY = "momentumLog";

    // Elements
    const currentDateEl = document.getElementById("current-date");
    const newEntryInput = document.getElementById("new-entry");
    const inputForm = document.getElementById("input-form");
    const pendingList = document.getElementById("pending-list");
    const doneList = document.getElementById("done-list");
    const searchInput = document.getElementById("search-input");
    const searchResults = document.getElementById("search-results");
    const exportBtn = document.getElementById("export-btn");
    const importFileInput = document.getElementById("import-file");
    const importLabel = document.getElementById("import-label");

    // State
    let data = [];
    let currentDateStr = "";
    let currentDayObj = null;
    let theme = "light";

    // Utilities
    function formatDate(date) {
      return date.toISOString().slice(0, 10);
    }
    function formatDateReadable(dateStr) {
      const d = new Date(dateStr + "T00:00:00");
      return d.toLocaleDateString(undefined, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
    }
    function timestamp() {
      const now = new Date();
      return now.toLocaleTimeString(undefined, { hour12: false, hour: "2-digit", minute: "2-digit" });
    }
    function saveData() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch {
        // ignore quota errors
      }
    }
    function loadData() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          data = JSON.parse(raw);
          if (!Array.isArray(data)) data = [];
        } else {
          data = [];
        }
      } catch {
        data = [];
      }
    }
    function getOrCreateDay(dateStr) {
      let day = data.find(d => d.date === dateStr);
      if (!day) {
        day = { date: dateStr, entries: [], completedCount: 0 };
        data.push(day);
      }
      return day;
    }
    function updateCompletedCount(day) {
      day.completedCount = day.entries.filter(e => e.done).length;
    }
    function renderDay() {
      currentDateStr = formatDate(new Date());
      currentDayObj = getOrCreateDay(currentDateStr);
      currentDateEl.textContent = formatDateReadable(currentDateStr);

      // Clear lists
      pendingList.innerHTML = "";
      doneList.innerHTML = "";

      // Separate entries by done status
      const pending = currentDayObj.entries.filter(e => !e.done);
      const done = currentDayObj.entries.filter(e => e.done);

      // Render entries
      for (const entry of pending) {
        pendingList.appendChild(createEntryElement(entry));
      }
      for (const entry of done) {
        doneList.appendChild(createEntryElement(entry));
      }
    }
    function createEntryElement(entry) {
      const li = document.createElement("li");
      li.tabIndex = 0;
      li.textContent = `[${entry.time}] ${entry.text}`;
      li.dataset.id = entry.id;
      li.setAttribute("draggable", "true");
      li.setAttribute("role", "listitem");
      li.setAttribute("aria-grabbed", "false");
      li.addEventListener("dragstart", onDragStart);
      li.addEventListener("dragend", onDragEnd);
      li.addEventListener("keydown", onEntryKeyDown);
      return li;
    }
    function addEntry(text) {
      if (!text.trim()) return;
      const timeStr = timestamp();
      const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
      const entry = { id, time: timeStr, text: text.trim(), done: false };
      currentDayObj.entries.push(entry);
      updateCompletedCount(currentDayObj);
      saveData();
      renderDay();
    }
    function onFormSubmit(e) {
      e.preventDefault();
      addEntry(newEntryInput.value);
      newEntryInput.value = "";
      newEntryInput.focus();
    }
    // Drag and drop handlers
    let draggedEntryId = null;
    function onDragStart(e) {
      draggedEntryId = e.target.dataset.id;
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", draggedEntryId);
      e.target.setAttribute("aria-grabbed", "true");
    }
    function onDragEnd(e) {
      e.target.setAttribute("aria-grabbed", "false");
      draggedEntryId = null;
    }
    function onDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    }
    function onDropPending(e) {
      e.preventDefault();
      const id = e.dataTransfer.getData("text/plain");
      if (!id) return;
      moveEntryToDone(id, false);
    }
    function onDropDone(e) {
      e.preventDefault();
      const id = e.dataTransfer.getData("text/plain");
      if (!id) return;
      moveEntryToDone(id, true);
    }
    function moveEntryToDone(id, doneStatus) {
      const entry = currentDayObj.entries.find(e => e.id === id);
      if (!entry) return;
      if (entry.done !== doneStatus) {
        entry.done = doneStatus;
        updateCompletedCount(currentDayObj);
        saveData();
        renderDay();
      }
    }
    // Keyboard accessibility for entries: Space or Enter toggles done state
    function onEntryKeyDown(e) {
      if (e.key === " " || e.key === "Enter") {
        e.preventDefault();
        const id = e.target.dataset.id;
        const entry = currentDayObj.entries.find(en => en.id === id);
        if (!entry) return;
        entry.done = !entry.done;
        updateCompletedCount(currentDayObj);
        saveData();
        renderDay();
        // Focus back on the toggled entry if possible
        setTimeout(() => {
          const list = entry.done ? doneList : pendingList;
          const el = list.querySelector(`li[data-id="${id}"]`);
          if (el) el.focus();
        }, 0);
      }
    }
    // Search functionality
    function renderSearchResults(query) {
      searchResults.innerHTML = "";
      if (!query.trim()) {
        renderHistory();
        return;
      }
      const q = query.toLowerCase();
      // Gather matching entries grouped by date
      const matchesByDate = {};
      for (const day of data) {
        const matches = day.entries.filter(e => e.text.toLowerCase().includes(q));
        if (matches.length) {
          matchesByDate[day.date] = matches;
        }
      }
      if (Object.keys(matchesByDate).length === 0) {
        searchResults.textContent = "No matching entries found.";
        return;
      }
      for (const dateStr of Object.keys(matchesByDate).sort((a,b) => b.localeCompare(a))) {
        const dayDiv = document.createElement("div");
        dayDiv.className = "search-day";
        const h3 = document.createElement("h3");
        h3.textContent = formatDateReadable(dateStr);
        dayDiv.appendChild(h3);
        const ul = document.createElement("ul");
        for (const entry of matchesByDate[dateStr]) {
          const li = document.createElement("li");
          li.textContent = `[${entry.time}] ${entry.text}${entry.done ? " (Done)" : ""}`;
          ul.appendChild(li);
        }
        dayDiv.appendChild(ul);
        searchResults.appendChild(dayDiv);
      }
    }
    // Render recent weeks history (last 4 weeks)
    function renderHistory() {
      searchResults.innerHTML = "";
      if (data.length === 0) {
        searchResults.textContent = "No historical entries yet.";
        return;
      }
      // Sort descending by date
      const sorted = data.slice().sort((a,b) => b.date.localeCompare(a.date));
      // Group by week (ISO week)
      function getWeekYear(dateStr) {
        const d = new Date(dateStr + "T00:00:00");
        // ISO week calculation
        const target = new Date(d.valueOf());
        const dayNr = (d.getDay() + 6) % 7;
        target.setDate(target.getDate() - dayNr + 3);
        const firstThursday = target.valueOf();
        target.setMonth(0, 1);
        if (target.getDay() !== 4) {
          target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
        }
        const weekNumber = 1 + Math.ceil((firstThursday - target) / 604800000);
        return `${d.getFullYear()}-W${weekNumber.toString().padStart(2,"0")}`;
      }
      const weeks = {};
      for (const day of sorted) {
        const wk = getWeekYear(day.date);
        if (!weeks[wk]) weeks[wk] = [];
        weeks[wk].push(day);
      }
      const weekKeys = Object.keys(weeks).sort((a,b) => b.localeCompare(a)).slice(0,4);
      for (const wk of weekKeys) {
        const weekDiv = document.createElement("div");
        weekDiv.className = "search-day";
        const h3 = document.createElement("h3");
        h3.textContent = `Week ${wk}`;
        weekDiv.appendChild(h3);
        for (const day of weeks[wk]) {
          const dayTitle = document.createElement("h4");
          dayTitle.textContent = formatDateReadable(day.date);
          dayTitle.style.margin = "0.5rem 0 0.25rem 0";
          weekDiv.appendChild(dayTitle);
          const ul = document.createElement("ul");
          for (const entry of day.entries) {
            const li = document.createElement("li");
            li.textContent = `[${entry.time}] ${entry.text}${entry.done ? " (Done)" : ""}`;
            ul.appendChild(li);
          }
          weekDiv.appendChild(ul);
        }
        searchResults.appendChild(weekDiv);
      }
    }
    // Theme toggle
    function applyTheme(t) {
      theme = t;
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("momentumLogTheme", theme);
    }
    function toggleTheme() {
      applyTheme(theme === "light" ? "dark" : "light");
    }
    function loadTheme() {
      const saved = localStorage.getItem("momentumLogTheme");
      if (saved === "dark" || saved === "light") {
        applyTheme(saved);
      } else {
        // Use prefers-color-scheme
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        applyTheme(prefersDark ? "dark" : "light");
      }
    }
    // Export data as text file
    function exportData() {
      let lines = [];
      for (const day of data) {
        lines.push(`=== ${formatDateReadable(day.date)} ===`);
        for (const entry of day.entries) {
          lines.push(`[${entry.time}]${entry.done ? " [Done]" : ""} ${entry.text}`);
        }
        lines.push("");
      }
      const blob = new Blob([lines.join("\n")], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `momentum-log-${currentDateStr}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    // Import data from text file (simple parser)
    function importData(text) {
      // Parse text file format:
      // === Date ===
      // [HH:mm] [Done] text
      // blank lines separate days
      const lines = text.split(/\r?\n/);
      let importedDays = [];
      let currentDay = null;
      for (const line of lines) {
        const dayMatch = line.match(/^=== (.+) ===$/);
        if (dayMatch) {
          if (currentDay) importedDays.push(currentDay);
          // Parse date from readable format back to ISO date if possible
          const parsedDate = new Date(dayMatch[1]);
          if (!isNaN(parsedDate)) {
            currentDay = { date: formatDate(parsedDate), entries: [], completedCount: 0 };
          } else {
            currentDay = null;
          }
          continue;
        }
        if (!currentDay) continue;
        const entryMatch = line.match(/^\[(\d{2}:\d{2})\](?: \[Done\])? (.+)$/);
        if (entryMatch) {
          const time = entryMatch[1];
          const text = entryMatch[2];
          const done = /\[Done\]/.test(line);
          const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
          currentDay.entries.push({ id, time, text, done });
        }
      }
      if (currentDay) importedDays.push(currentDay);
      if (importedDays.length === 0) return false;
      // Merge imported days with existing data by date
      for (const impDay of importedDays) {
        const existing = data.find(d => d.date === impDay.date);
        if (existing) {
          // Append entries avoiding duplicates by text+time
          for (const e of impDay.entries) {
            if (!existing.entries.some(en => en.text === e.text && en.time === e.time)) {
              existing.entries.push(e);
            }
          }
          updateCompletedCount(existing);
        } else {
          updateCompletedCount(impDay);
          data.push(impDay);
        }
      }
      saveData();
      renderDay();
      renderSearchResults(searchInput.value);
      return true;
    }
    // Accessibility helper: visually hidden class
    const styleVisuallyHidden = document.createElement("style");
    styleVisuallyHidden.textContent = `.visually-hidden { position: absolute !important; width: 1px !important; height: 1px !important; padding: 0 !important; margin: -1px !important; overflow: hidden !important; clip: rect(0,0,0,0) !important; white-space: nowrap !important; border: 0 !important; }`;
    document.head.appendChild(styleVisuallyHidden);

    // Event listeners
    inputForm.addEventListener("submit", onFormSubmit);
    newEntryInput.addEventListener("keydown", e => {
      if (e.ctrlKey && e.key === "Enter") {
        e.preventDefault();
        inputForm.requestSubmit();
      }
    });
    pendingList.addEventListener("dragover", onDragOver);
    doneList.addEventListener("dragover", onDragOver);
    pendingList.addEventListener("drop", onDropPending);
    doneList.addEventListener("drop", onDropDone);

    searchInput.addEventListener("input", e => {
      renderSearchResults(e.target.value);
    });

    exportBtn.addEventListener("click", exportData);

    importFileInput.addEventListener("change", e => {
      const file = e.target.files;
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        if (!importData(evt.target.result)) {
          alert("Failed to import data: invalid format.");
        }
      };
      reader.readAsText(file);
      importFileInput.value = "";
    });
    importLabel.addEventListener("keydown", e => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        importFileInput.click();
      }
    });

    // Keyboard shortcuts
    window.addEventListener("keydown", e => {
      if (e.ctrlKey && !e.shiftKey && !e.altKey) {
        switch (e.key.toLowerCase()) {
          case "f":
            e.preventDefault();
            searchInput.focus();
            break;
          case "t":
            e.preventDefault();
            toggleTheme();
            break;
          case "e":
            e.preventDefault();
            exportData();
            break;
          case "i":
            e.preventDefault();
            importFileInput.click();
            break;
        }
      }
    });

    // Auto-save on every keystroke in new entry input
    newEntryInput.addEventListener("input", () => {
      saveData();
    });

    // Initialization
    function init() {
      loadData();
      loadTheme();
      renderDay();
      renderHistory();
    }
    init();
  })();
</script>
</body>
</html>