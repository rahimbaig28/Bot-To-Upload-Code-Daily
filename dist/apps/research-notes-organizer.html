<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-02T13:21:47.653025Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Research Notes Organizer</title>
<style>
  :root {
    --focus-outline: 2px solid #005fcc;
    --color-bg: #fff;
    --color-text: #222;
    --color-accent: #005fcc;
    --color-tag-bg: #e0e7ff;
    --color-tag-hover: #c7d2fe;
    --color-border: #ccc;
    --color-error: #c00;
  }
  body {
    margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    background: var(--color-bg);
    color: var(--color-text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  header {
    background: var(--color-accent);
    color: white;
    padding: 1rem 1rem 0.75rem 1rem;
    text-align: center;
    font-weight: 600;
    font-size: 1.25rem;
  }
  main {
    flex: 1 1 auto;
    padding: 1rem;
    max-width: 900px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  form {
    border: 1px solid var(--color-border);
    padding: 1rem;
    border-radius: 4px;
    background: #f9f9f9;
  }
  form > div {
    margin-bottom: 0.75rem;
  }
  label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.25rem;
  }
  input[type="text"],
  input[type="url"],
  textarea {
    width: 100%;
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: 3px;
    font-family: inherit;
    resize: vertical;
  }
  textarea {
    min-height: 80px;
  }
  input[type="text"]:focus,
  input[type="url"]:focus,
  textarea:focus,
  button:focus,
  summary:focus {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  button {
    font-size: 1rem;
    padding: 0.4rem 0.8rem;
    border: 1px solid var(--color-accent);
    background: var(--color-accent);
    color: white;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
  }
  button[disabled] {
    opacity: 0.5;
    cursor: default;
  }
  button + button {
    margin-left: 0.5rem;
  }
  #notes-filter {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }
  #search-text {
    flex: 1 1 200px;
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: 3px;
  }
  #tags-filter {
    flex: 1 1 150px;
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: 3px;
  }
  #notes-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .note-item {
    border: 1px solid var(--color-border);
    border-radius: 4px;
    margin-bottom: 0.75rem;
    background: #fff;
  }
  .note-summary {
    cursor: pointer;
    padding: 0.75rem 1rem;
    font-weight: 600;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .note-summary:focus {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  .note-title {
    flex: 1 1 auto;
  }
  .note-tags {
    flex: 0 0 auto;
    display: flex;
    gap: 0.3rem;
    flex-wrap: wrap;
    margin-left: 1rem;
  }
  .tag {
    background: var(--color-tag-bg);
    color: var(--color-accent);
    padding: 0.15rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    cursor: pointer;
    user-select: none;
  }
  .tag:hover,
  .tag:focus {
    background: var(--color-tag-hover);
    outline: none;
  }
  .note-content {
    padding: 0 1rem 1rem 1rem;
    font-size: 0.95rem;
    white-space: pre-wrap;
    line-height: 1.4;
  }
  .note-content a {
    color: var(--color-accent);
    text-decoration: underline;
  }
  .note-actions {
    padding: 0 1rem 1rem 1rem;
    display: flex;
    gap: 0.5rem;
  }
  .note-actions button {
    background: transparent;
    border: 1px solid var(--color-accent);
    color: var(--color-accent);
    padding: 0.3rem 0.6rem;
    font-size: 0.85rem;
    border-radius: 3px;
  }
  .note-actions button:hover,
  .note-actions button:focus {
    background: var(--color-accent);
    color: white;
  }
  .hidden {
    display: none !important;
  }
  .error-msg {
    color: var(--color-error);
    font-size: 0.9rem;
    margin-top: -0.5rem;
    margin-bottom: 0.5rem;
  }
  #import-file {
    display: none;
  }
  footer {
    padding: 0.5rem 1rem 1rem 1rem;
    text-align: center;
    font-size: 0.85rem;
    color: #666;
  }
  @media (max-width: 600px) {
    #notes-filter {
      flex-direction: column;
      align-items: stretch;
    }
    #search-text,
    #tags-filter {
      flex: 1 1 100%;
    }
    .note-summary {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.4rem;
    }
    .note-tags {
      margin-left: 0;
    }
  }
</style>
</head>
<body>
<header>
  Research Notes Organizer
</header>
<main>
  <section aria-label="Add or edit research note">
    <form id="note-form" aria-describedby="form-desc" novalidate>
      <div id="form-desc" class="sr-only">Add or edit a research note with title, content, tags, and optional URL reference.</div>
      <input type="hidden" id="note-id" />
      <div>
        <label for="note-title">Title <span aria-hidden="true">*</span></label>
        <input type="text" id="note-title" name="title" required aria-required="true" autocomplete="off" />
        <div id="title-error" class="error-msg" role="alert" aria-live="assertive" hidden>Title is required.</div>
      </div>
      <div>
        <label for="note-content">Content (Markdown-style supported)</label>
        <textarea id="note-content" name="content" rows="5" aria-multiline="true"></textarea>
      </div>
      <div>
        <label for="note-tags">Tags (comma separated)</label>
        <input type="text" id="note-tags" name="tags" autocomplete="off" />
      </div>
      <div>
        <label for="note-url">URL Reference (optional)</label>
        <input type="url" id="note-url" name="url" placeholder="https://example.com" autocomplete="off" />
        <div id="url-error" class="error-msg" role="alert" aria-live="assertive" hidden>Invalid URL format.</div>
      </div>
      <div>
        <button type="submit" id="save-note-btn">Add Note</button>
        <button type="button" id="cancel-edit-btn" class="hidden">Cancel Edit</button>
      </div>
    </form>
  </section>

  <section aria-label="Filter and search notes" id="notes-filter" role="search">
    <input type="search" id="search-text" aria-label="Search notes by text" placeholder="Search notes..." autofocus />
    <input type="text" id="tags-filter" aria-label="Filter notes by tags (comma separated)" placeholder="Filter by tags" autocomplete="off" />
    <button type="button" id="clear-filters-btn" aria-label="Clear search and tag filters">Clear Filters</button>
  </section>

  <section aria-label="Notes list" id="notes-section">
    <ul id="notes-list" role="list" tabindex="0" aria-live="polite" aria-relevant="additions removals"></ul>
  </section>

  <section aria-label="Data management" id="data-management" style="margin-top:1rem;">
    <button type="button" id="export-btn" aria-label="Export notes as JSON file">Export Notes</button>
    <button type="button" id="import-btn" aria-label="Import notes from JSON file">Import Notes</button>
    <input type="file" id="import-file" accept="application/json" aria-hidden="true" />
    <button type="button" id="share-url-btn" aria-label="Generate shareable URL with current notes and filters">Generate Shareable URL</button>
  </section>
</main>
<footer>
  &copy; 2025 Research Notes Organizer
</footer>
<script>
(() => {
  "use strict";

  // Elements
  const noteForm = document.getElementById('note-form');
  const noteIdInput = document.getElementById('note-id');
  const titleInput = document.getElementById('note-title');
  const contentInput = document.getElementById('note-content');
  const tagsInput = document.getElementById('note-tags');
  const urlInput = document.getElementById('note-url');
  const saveBtn = document.getElementById('save-note-btn');
  const cancelEditBtn = document.getElementById('cancel-edit-btn');
  const titleError = document.getElementById('title-error');
  const urlError = document.getElementById('url-error');

  const searchTextInput = document.getElementById('search-text');
  const tagsFilterInput = document.getElementById('tags-filter');
  const clearFiltersBtn = document.getElementById('clear-filters-btn');

  const notesList = document.getElementById('notes-list');

  const exportBtn = document.getElementById('export-btn');
  const importBtn = document.getElementById('import-btn');
  const importFileInput = document.getElementById('import-file');
  const shareUrlBtn = document.getElementById('share-url-btn');

  // Data keys
  const STORAGE_KEY = 'research_notes_organizer';
  const UI_STATE_KEY = 'research_notes_ui_state';

  // State
  let notes = [];
  let filterText = '';
  let filterTags = [];

  // Helpers
  function sanitizeText(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Simple markdown-style to HTML converter for bold, italic, links, and line breaks
  function markdownToHtml(md) {
    if (!md) return '';
    // Escape HTML first
    let html = md.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    // Links: [text](url)
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    // Bold: **text** or __text__
    html = html.replace(/(\*\*|__)(.*?)\1/g, '<strong>$2</strong>');
    // Italic: *text* or _text_
    html = html.replace(/(\*|_)(.*?)\1/g, '<em>$2</em>');
    // Line breaks: \n to <br>
    html = html.replace(/\n/g, '<br>');
    return html;
  }

  function parseTags(tagsStr) {
    return tagsStr.split(',')
      .map(t => t.trim().toLowerCase())
      .filter(t => t.length > 0);
  }

  function uniqueTagsFromNotes(notesArray) {
    const tagSet = new Set();
    notesArray.forEach(note => {
      if (note.tags && Array.isArray(note.tags)) {
        note.tags.forEach(t => tagSet.add(t.toLowerCase()));
      }
    });
    return Array.from(tagSet).sort();
  }

  function saveNotesToStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
    } catch (e) {
      alert('Error saving notes to localStorage.');
    }
  }

  function saveUIStateToStorage() {
    const uiState = {
      filterText,
      filterTags,
      expandedNoteIds: Array.from(notesList.querySelectorAll('details[open]')).map(d => d.dataset.id)
    };
    try {
      localStorage.setItem(UI_STATE_KEY, JSON.stringify(uiState));
    } catch (e) {
      // ignore
    }
  }

  function loadNotesFromStorage() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          notes = parsed.map(n => ({
            id: n.id || generateId(),
            title: n.title || '',
            content: n.content || '',
            tags: Array.isArray(n.tags) ? n.tags.map(t => t.toLowerCase()) : [],
            url: n.url || ''
          }));
        }
      }
    } catch (e) {
      notes = [];
    }
  }

  function loadUIStateFromStorage() {
    try {
      const stored = localStorage.getItem(UI_STATE_KEY);
      if (stored) {
        const uiState = JSON.parse(stored);
        if (uiState) {
          filterText = uiState.filterText || '';
          filterTags = Array.isArray(uiState.filterTags) ? uiState.filterTags : [];
          searchTextInput.value = filterText;
          tagsFilterInput.value = filterTags.join(', ');
          return uiState.expandedNoteIds || [];
        }
      }
    } catch (e) {
      // ignore
    }
    return [];
  }

  function generateId() {
    return 'n_' + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
  }

  function clearForm() {
    noteIdInput.value = '';
    titleInput.value = '';
    contentInput.value = '';
    tagsInput.value = '';
    urlInput.value = '';
    titleError.hidden = true;
    urlError.hidden = true;
    saveBtn.textContent = 'Add Note';
    cancelEditBtn.classList.add('hidden');
    noteForm.querySelector('input,textarea').focus();
  }

  function validateForm() {
    let valid = true;
    titleError.hidden = true;
    urlError.hidden = true;
    if (!titleInput.value.trim()) {
      titleError.hidden = false;
      valid = false;
    }
    if (urlInput.value.trim()) {
      try {
        new URL(urlInput.value.trim());
      } catch {
        urlError.hidden = false;
        valid = false;
      }
    }
    return valid;
  }

  function renderNotes() {
    // Filter notes by text and tags
    const filtered = notes.filter(note => {
      const textMatch =
        note.title.toLowerCase().includes(filterText) ||
        note.content.toLowerCase().includes(filterText) ||
        note.tags.some(t => t.includes(filterText));
      const tagsMatch = filterTags.length === 0 || filterTags.every(ft => note.tags.includes(ft));
      return textMatch && tagsMatch;
    });

    notesList.innerHTML = '';
    if (filtered.length === 0) {
      const li = document.createElement('li');
      li.textContent = 'No notes found.';
      li.style.fontStyle = 'italic';
      notesList.appendChild(li);
      return;
    }

    filtered.forEach(note => {
      const li = document.createElement('li');
      li.className = 'note-item';

      const details = document.createElement('details');
      details.dataset.id = note.id;
      details.setAttribute('role', 'region');
      details.setAttribute('aria-labelledby', `summary-${note.id}`);

      const summary = document.createElement('summary');
      summary.className = 'note-summary';
      summary.id = `summary-${note.id}`;
      summary.tabIndex = 0;
      summary.setAttribute('aria-controls', `content-${note.id}`);
      summary.setAttribute('aria-expanded', 'false');

      const titleSpan = document.createElement('span');
      titleSpan.className = 'note-title';
      titleSpan.textContent = note.title;
      summary.appendChild(titleSpan);

      const tagsSpan = document.createElement('span');
      tagsSpan.className = 'note-tags';
      note.tags.forEach(tag => {
        const tagBtn = document.createElement('button');
        tagBtn.type = 'button';
        tagBtn.className = 'tag';
        tagBtn.textContent = tag;
        tagBtn.setAttribute('aria-label', `Filter notes by tag ${tag}`);
        tagBtn.addEventListener('click', e => {
          e.stopPropagation();
          addTagFilter(tag);
        });
        tagsSpan.appendChild(tagBtn);
      });
      summary.appendChild(tagsSpan);

      details.appendChild(summary);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'note-content';
      contentDiv.id = `content-${note.id}`;
      contentDiv.setAttribute('aria-live', 'polite');
      contentDiv.innerHTML = markdownToHtml(note.content);

      if (note.url) {
        const urlLink = document.createElement('a');
        urlLink.href = note.url;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = 'Reference Link';
        urlLink.style.display = 'block';
        urlLink.style.marginTop = '0.5rem';
        contentDiv.appendChild(urlLink);
      }

      details.appendChild(contentDiv);

      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'note-actions';

      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.textContent = 'Edit';
      editBtn.setAttribute('aria-label', `Edit note titled ${note.title}`);
      editBtn.addEventListener('click', () => {
        startEditNote(note.id);
      });
      actionsDiv.appendChild(editBtn);

      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = 'Delete';
      deleteBtn.setAttribute('aria-label', `Delete note titled ${note.title}`);
      deleteBtn.addEventListener('click', () => {
        confirmDeleteNote(note.id);
      });
      actionsDiv.appendChild(deleteBtn);

      details.appendChild(actionsDiv);

      // Update aria-expanded on toggle
      details.addEventListener('toggle', () => {
        summary.setAttribute('aria-expanded', details.open ? 'true' : 'false');
        saveUIStateToStorage();
      });

      li.appendChild(details);
      notesList.appendChild(li);
    });
  }

  function addTagFilter(tag) {
    tag = tag.toLowerCase();
    if (!filterTags.includes(tag)) {
      filterTags.push(tag);
      tagsFilterInput.value = filterTags.join(', ');
      saveFiltersAndRender();
      tagsFilterInput.focus();
    }
  }

  function saveFiltersAndRender() {
    filterText = searchTextInput.value.trim().toLowerCase();
    filterTags = parseTags(tagsFilterInput.value);
    saveUIStateToStorage();
    renderNotes();
  }

  function startEditNote(id) {
    const note = notes.find(n => n.id === id);
    if (!note) return;
    noteIdInput.value = note.id;
    titleInput.value = note.title;
    contentInput.value = note.content;
    tagsInput.value = note.tags.join(', ');
    urlInput.value = note.url || '';
    saveBtn.textContent = 'Save Changes';
    cancelEditBtn.classList.remove('hidden');
    titleError.hidden = true;
    urlError.hidden = true;
    titleInput.focus();
  }

  function confirmDeleteNote(id) {
    const note = notes.find(n => n.id === id);
    if (!note) return;
    if (confirm(`Are you sure you want to delete the note titled "${note.title}"? This action cannot be undone.`)) {
      notes = notes.filter(n => n.id !== id);
      saveNotesToStorage();
      saveUIStateToStorage();
      renderNotes();
      if (noteIdInput.value === id) {
        clearForm();
      }
    }
  }

  function handleFormSubmit(e) {
    e.preventDefault();
    if (!validateForm()) return;

    const id = noteIdInput.value;
    const title = titleInput.value.trim();
    const content = contentInput.value.trim();
    const tags = parseTags(tagsInput.value);
    const url = urlInput.value.trim();

    if (id) {
      // Edit existing
      const idx = notes.findIndex(n => n.id === id);
      if (idx !== -1) {
        notes[idx] = { id, title, content, tags, url };
      }
    } else {
      // Add new
      notes.push({ id: generateId(), title, content, tags, url });
    }
    saveNotesToStorage();
    saveUIStateToStorage();
    renderNotes();
    clearForm();
  }

  function handleCancelEdit() {
    clearForm();
  }

  function handleClearFilters() {
    searchTextInput.value = '';
    tagsFilterInput.value = '';
    filterText = '';
    filterTags = [];
    saveUIStateToStorage();
    renderNotes();
    searchTextInput.focus();
  }

  function exportNotes() {
    const dataStr = JSON.stringify(notes, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'research-notes.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  function importNotesFromFile(file, replace = false) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const imported = JSON.parse(reader.result);
        if (!Array.isArray(imported)) throw new Error('Invalid JSON format: expected an array');
        // Validate minimal structure
        const validNotes = imported.filter(n =>
          n && typeof n.title === 'string' && typeof n.content === 'string' &&
          (Array.isArray(n.tags) || typeof n.tags === 'string' || n.tags === undefined)
        ).map(n => ({
          id: n.id || generateId(),
          title: n.title,
          content: n.content,
          tags: Array.isArray(n.tags) ? n.tags.map(t => t.toLowerCase()) : (typeof n.tags === 'string' ? parseTags(n.tags) : []),
          url: n.url || ''
        }));
        if (replace) {
          notes = validNotes;
        } else {
          // Merge: add only new notes by id
          const existingIds = new Set(notes.map(n => n.id));
          validNotes.forEach(n => {
            if (!existingIds.has(n.id)) notes.push(n);
          });
        }
        saveNotesToStorage();
        saveUIStateToStorage();
        renderNotes();
        alert(`Imported ${validNotes.length} notes successfully.`);
      } catch (err) {
        alert('Failed to import notes: ' + err.message);
      }
    };
    reader.onerror = () => {
      alert('Error reading file.');
    };
    reader.readAsText(file);
  }

  function handleImportClick() {
    importFileInput.value = '';
    importFileInput.click();
  }

  function handleFileSelected(e) {
    const file = e.target.files;
    if (!file) return;
    if (!file.name.toLowerCase().endsWith('.json')) {
      alert('Please select a valid JSON file.');
      return;
    }
    if (notes.length > 0) {
      if (confirm('Importing will merge with existing notes. Click Cancel to replace all notes instead. Proceed with merge?')) {
        importNotesFromFile(file, false);
      } else {
        if (confirm('Are you sure you want to replace all existing notes with the imported notes? This cannot be undone.')) {
          importNotesFromFile(file, true);
        }
      }
    } else {
      importNotesFromFile(file, true);
    }
  }

  function generateShareableURL() {
    // Encode notes and filters into URL hash as base64 JSON
    const data = {
      notes,
      filterText,
      filterTags
    };
    try {
      const jsonStr = JSON.stringify(data);
      const encoded = btoa(encodeURIComponent(jsonStr));
      const url = `${location.origin}${location.pathname}#data=${encoded}`;
      prompt('Shareable URL (copy to clipboard):', url);
    } catch {
      alert('Failed to generate shareable URL.');
    }
  }

  function loadFromURLHash() {
    if (!location.hash.startsWith('#data=')) return false;
    try {
      const encoded = location.hash.slice(6);
      const jsonStr = decodeURIComponent(atob(encoded));
      const data = JSON.parse(jsonStr);
      if (data.notes && Array.isArray(data.notes)) {
        notes = data.notes.map(n => ({
          id: n.id || generateId(),
          title: n.title || '',
          content: n.content || '',
          tags: Array.isArray(n.tags) ? n.tags.map(t => t.toLowerCase()) : [],
          url: n.url || ''
        }));
        filterText = data.filterText || '';
        filterTags = Array.isArray(data.filterTags) ? data.filterTags : [];
        searchTextInput.value = filterText;
        tagsFilterInput.value = filterTags.join(', ');
        saveNotesToStorage();
        saveUIStateToStorage();
        renderNotes();
        return true;
      }
    } catch {
      // ignore
    }
    return false;
  }

  // Keyboard navigation enhancements for notes list
  function setupKeyboardNavigation() {
    notesList.addEventListener('keydown', e => {
      const focusEl = document.activeElement;
      if (!notesList.contains(focusEl)) return;
      if (focusEl.tagName !== 'SUMMARY') return;

      switch (e.key) {
        case 'ArrowDown': {
          e.preventDefault();
          let next = focusEl.parentElement.nextElementSibling;
          while (next && !next.querySelector('summary')) next = next.nextElementSibling;
          if (next) next.querySelector('summary').focus();
          break;
        }
        case 'ArrowUp': {
          e.preventDefault();
          let prev = focusEl.parentElement.previousElementSibling;
          while (prev && !prev.querySelector('summary')) prev = prev.previousElementSibling;
          if (prev) prev.querySelector('summary').focus();
          break;
        }
        case 'Enter':
        case ' ': {
          // Toggle details open/close on Enter or Space
          e.preventDefault();
          const details = focusEl.parentElement;
          details.open = !details.open;
          focusEl.setAttribute('aria-expanded', details.open ? 'true' : 'false');
          saveUIStateToStorage();
          break;
        }
      }
    });
  }

  // Initialization
  function init() {
    if (!loadFromURLHash()) {
      loadNotesFromStorage();
      const expandedIds = loadUIStateFromStorage();
      renderNotes();
      // Expand stored expanded notes
      expandedIds.forEach(id => {
        const details = notesList.querySelector(`details[data-id="${id}"]`);
        if (details) {
          details.open = true;
          const summary = details.querySelector('summary');
          if (summary) summary.setAttribute('aria-expanded', 'true');
        }
      });
    }
    setupKeyboardNavigation();
    titleInput.focus();
  }

  // Event listeners
  noteForm.addEventListener('submit', handleFormSubmit);
  cancelEditBtn.addEventListener('click', handleCancelEdit);
  searchTextInput.addEventListener('input', () => {
    filterText = searchTextInput.value.trim().toLowerCase();
    saveFiltersAndRender();
  });
  tagsFilterInput.addEventListener('input', () => {
    filterTags = parseTags(tagsFilterInput.value);
    saveFiltersAndRender();
  });
  clearFiltersBtn.addEventListener('click', handleClearFilters);
  exportBtn.addEventListener('click', exportNotes);
  importBtn.addEventListener('click', handleImportClick);
  importFileInput.addEventListener('change', handleFileSelected);
  shareUrlBtn.addEventListener('click', generateShareableURL);

  // Accessibility: screen reader only style
  const style = document.createElement('style');
  style.textContent = `.sr-only {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0,0,0,0) !important;
    white-space: nowrap !important;
    border: 0 !important;
  }`;
  document.head.appendChild(style);

  // Start app
  init();
})();  
</script>
</body>
</html>