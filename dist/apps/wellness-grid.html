<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-09T13:21:19.715310Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wellness Grid</title>
  <style>
    :root {
      --bg: #f8f9fa;
      --text: #212529;
      --tile-bg: #ffffff;
      --tile-border: #dee2e6;
      --done: #28a745;
      --skipped: #dc3545;
      --active: #007bff;
      --focus: #ffc107;
      --high-contrast-bg: #000;
      --high-contrast-text: #fff;
      --high-contrast-tile-bg: #222;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      padding: 1rem;
      transition: background 0.2s, color 0.2s;
    }
    body.high-contrast {
      background: var(--high-contrast-bg);
      color: var(--high-contrast-text);
    }
    .skip-link {
      position: absolute;
      left: -9999px;
      top: 0;
      background: var(--active);
      color: white;
      padding: 0.5rem;
      z-index: 100;
    }
    .skip-link:focus {
      left: 0;
    }
    h1 { margin-bottom: 1rem; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    button, select, input {
      padding: 0.5rem;
      border: 1px solid var(--tile-border);
      background: var(--tile-bg);
      color: var(--text);
      border-radius: 4px;
      font-size: 1rem;
    }
    button:focus, select:focus, input:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .tile {
      background: var(--tile-bg);
      border: 1px solid var(--tile-border);
      border-radius: 8px;
      padding: 1rem;
      position: relative;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      cursor: move;
      user-select: none;
      touch-action: none;
    }
    body.high-contrast .tile {
      background: var(--high-contrast-tile-bg);
    }
    .tile:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }
    .tile.done { background: var(--done); color: white; }
    .tile.skipped { background: var(--skipped); color: white; }
    .tile-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }
    .tile-title {
      font-weight: bold;
      flex-grow: 1;
    }
    .tile-actions {
      display: flex;
      gap: 0.25rem;
    }
    .tile-actions button {
      padding: 0.25rem;
      font-size: 0.8rem;
      min-width: 24px;
    }
    .tile-streak {
      font-size: 0.8rem;
      margin-top: 0.5rem;
    }
    .tile-notes {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      flex-grow: 1;
    }
    .tile-notes textarea {
      width: 100%;
      min-height: 40px;
      resize: vertical;
      border: 1px solid var(--tile-border);
      padding: 0.25rem;
      font-size: 0.9rem;
      background: var(--tile-bg);
      color: var(--text);
    }
    .mood-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .mood-emoji {
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.5rem;
      border: 1px solid var(--tile-border);
      border-radius: 4px;
      background: var(--tile-bg);
    }
    .mood-emoji:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }
    .mood-log {
      margin-top: 1rem;
    }
    .mood-entry {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .mood-entry-date {
      font-weight: bold;
    }
    .data-actions {
      margin-top: 1rem;
    }
    .data-actions textarea {
      width: 100%;
      min-height: 80px;
      margin-bottom: 0.5rem;
      font-family: monospace;
      resize: vertical;
    }
    @media (max-width: 600px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <a href="#main" class="skip-link">Skip to main content</a>
  <div class="controls">
    <button id="add-habit" aria-label="Add new habit">+ Habit</button>
    <select id="habit-type" aria-label="Habit type">
      <option value="hydration">Hydration</option>
      <option value="exercise">Exercise</option>
      <option value="meditation">Meditation</option>
      <option value="custom">Custom</option>
    </select>
    <input id="custom-habit" type="text" placeholder="Custom habit name" aria-label="Custom habit name">
    <button id="contrast-toggle" aria-label="Toggle high contrast mode">‚òÄÔ∏è/üåô</button>
  </div>
  <main id="main">
    <h1>Wellness Grid</h1>
    <div class="grid" id="grid" role="grid" aria-label="Daily habits grid"></div>
    <div class="mood-picker" aria-label="Mood picker">
      <span class="mood-emoji" tabindex="0" role="button" aria-label="Happy mood">üòä</span>
      <span class="mood-emoji" tabindex="0" role="button" aria-label="Neutral mood">üòê</span>
      <span class="mood-emoji" tabindex="0" role="button" aria-label="Sad mood">üòû</span>
      <span class="mood-emoji" tabindex="0" role="button" aria-label="Angry mood">üò†</span>
      <span class="mood-emoji" tabindex="0" role="button" aria-label="Tired mood">üò¥</span>
    </div>
    <div class="mood-log" aria-label="Mood log">
      <h2>Mood Timeline</h2>
      <div id="mood-timeline"></div>
    </div>
    <div class="data-actions" aria-label="Data actions">
      <h2>Export/Import</h2>
      <textarea id="export-data" placeholder="Exported data will appear here" aria-label="Export data"></textarea>
      <button id="export-btn" aria-label="Export grid and mood data">Export</button>
      <button id="import-btn" aria-label="Import grid and mood data">Import</button>
    </div>
  </main>
  <script>
    // State
    let habits = [];
    let moods = [];
    let draggedTile = null;
    let draggedIndex = null;
    let isHighContrast = false;

    // DOM
    const grid = document.getElementById('grid');
    const addHabitBtn = document.getElementById('add-habit');
    const habitType = document.getElementById('habit-type');
    const customHabit = document.getElementById('custom-habit');
    const moodEmojis = document.querySelectorAll('.mood-emoji');
    const moodTimeline = document.getElementById('mood-timeline');
    const exportData = document.getElementById('export-data');
    const exportBtn = document.getElementById('export-btn');
    const importBtn = document.getElementById('import-btn');
    const contrastToggle = document.getElementById('contrast-toggle');

    // Load data
    function loadData() {
      const saved = localStorage.getItem('wellnessGrid');
      if (saved) {
        const data = JSON.parse(saved);
        habits = data.habits || [];
        moods = data.moods || [];
      }
      renderGrid();
      renderMoodLog();
    }

    // Save data
    function saveData() {
      localStorage.setItem('wellnessGrid', JSON.stringify({ habits, moods }));
    }

    // Render grid
    function renderGrid() {
      grid.innerHTML = '';
      habits.forEach((habit, index) => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('draggable', 'true');
        tile.setAttribute('role', 'gridcell');
        tile.setAttribute('aria-label', `${habit.name} habit tile`);
        tile.setAttribute('tabindex', '0');
        tile.dataset.index = index;

        const today = new Date().toISOString().split('T');
        const todayLog = habit.logs.find(l => l.date === today);
        if (todayLog) {
          tile.classList.add(todayLog.status);
        }

        tile.innerHTML = `
          <div class="tile-header">
            <span class="tile-title">${habit.name}</span>
            <div class="tile-actions">
              <button class="done-btn" aria-label="Mark ${habit.name} as done">‚úì</button>
              <button class="skipped-btn" aria-label="Mark ${habit.name} as skipped">‚úó</button>
              <button class="remove-btn" aria-label="Remove ${habit.name}">√ó</button>
            </div>
          </div>
          <div class="tile-streak">Streak: ${habit.streak || 0}</div>
          <div class="tile-notes">
            <textarea placeholder="Notes" aria-label="Notes for ${habit.name}">${todayLog?.notes || ''}</textarea>
          </div>
        `;

        tile.querySelector('.done-btn').addEventListener('click', () => toggleHabitStatus(index, 'done'));
        tile.querySelector('.skipped-btn').addEventListener('click', () => toggleHabitStatus(index, 'skipped'));
        tile.querySelector('.remove-btn').addEventListener('click', () => removeHabit(index));
        tile.querySelector('textarea').addEventListener('change', (e) => updateHabitNotes(index, e.target.value));

        // Drag events
        tile.addEventListener('dragstart', (e) => {
          draggedTile = tile;
          draggedIndex = index;
          e.dataTransfer.setData('text/plain', index);
          setTimeout(() => tile.classList.add('dragging'), 0);
        });
        tile.addEventListener('dragend', () => {
          tile.classList.remove('dragging');
          draggedTile = null;
          draggedIndex = null;
        });
        tile.addEventListener('dragover', (e) => {
          e.preventDefault();
          const afterElement = getDragAfterElement(grid, e.clientY);
          if (afterElement) {
            grid.insertBefore(tile, afterElement);
          } else {
            grid.appendChild(tile);
          }
        });

        // Keyboard reorder
        tile.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const dir = e.key === 'ArrowUp' ? -1 : 1;
            const newIndex = index + dir;
            if (newIndex >= 0 && newIndex < habits.length) {
              [habits[index], habits[newIndex]] = [habits[newIndex], habits[index]];
              saveData();
              renderGrid();
              grid.children[newIndex].focus();
            }
          }
        });

        grid.appendChild(tile);
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.tile:not(.dragging)')];
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Habit actions
    function addHabit() {
      const type = habitType.value;
      let name = type === 'custom' ? customHabit.value.trim() : type.charAt(0).toUpperCase() + type.slice(1);
      if (!name) return;
      habits.push({
        id: Date.now(),
        name,
        logs: [],
        streak: 0
      });
      customHabit.value = '';
      saveData();
      renderGrid();
    }

    function removeHabit(index) {
      habits.splice(index, 1);
      saveData();
      renderGrid();
    }

    function toggleHabitStatus(index, status) {
      const today = new Date().toISOString().split('T');
      const habit = habits[index];
      const todayLogIndex = habit.logs.findIndex(l => l.date === today);
      if (todayLogIndex >= 0) {
        habit.logs[todayLogIndex].status = status;
      } else {
        habit.logs.push({ date: today, status, notes: '' });
      }
      updateStreak(index);
      saveData();
      renderGrid();
    }

    function updateHabitNotes(index, notes) {
      const today = new Date().toISOString().split('T');
      const habit = habits[index];
      const todayLogIndex = habit.logs.findIndex(l => l.date === today);
      if (todayLogIndex >= 0) {
        habit.logs[todayLogIndex].notes = notes;
      } else {
        habit.logs.push({ date: today, status: '', notes });
      }
      saveData();
    }

    function updateStreak(index) {
      const habit = habits[index];
      const today = new Date().toISOString().split('T');
      const sortedLogs = [...habit.logs].sort((a, b) => new Date(a.date) - new Date(b.date));
      let streak = 0;
      let prevDate = null;
      for (const log of sortedLogs) {
        if (log.status === 'done') {
          const logDate = new Date(log.date);
          if (!prevDate || (logDate - prevDate) === 86400000) {
            streak++;
          } else if ((logDate - prevDate) > 86400000) {
            streak = 1;
          }
          prevDate = logDate;
        } else if (log.status === 'skipped') {
          streak = 0;
        }
      }
      habit.streak = streak;
    }

    // Mood actions
    function logMood(emoji) {
      const today = new Date().toISOString().split('T');
      const existing = moods.find(m => m.date === today);
      if (existing) {
        existing.emoji = emoji;
      } else {
        moods.push({ date: today, emoji });
      }
      saveData();
      renderMoodLog();
    }

    function renderMoodLog() {
      moodTimeline.innerHTML = '';
      const sorted = [...moods].sort((a, b) => new Date(b.date) - new Date(a.date));
      sorted.forEach(mood => {
        const entry = document.createElement('div');
        entry.className = 'mood-entry';
        entry.innerHTML = `
          <span class="mood-entry-date">${mood.date}</span>
          <span class="mood-emoji" aria-label="Mood on ${mood.date}">${mood.emoji}</span>
        `;
        moodTimeline.appendChild(entry);
      });
    }

    // Export/import
    function exportDataToJson() {
      exportData.value = JSON.stringify({ habits, moods }, null, 2);
    }

    function importDataFromJson() {
      try {
        const data = JSON.parse(exportData.value);
        if (data.habits && data.moods) {
          habits = data.habits;
          moods = data.moods;
          saveData();
          renderGrid();
          renderMoodLog();
        }
      } catch (e) {
        alert('Invalid JSON');
      }
    }

    // Contrast toggle
    function toggleContrast() {
      isHighContrast = !isHighContrast;
      document.body.classList.toggle('high-contrast', isHighContrast);
      localStorage.setItem('wellnessGridHighContrast', isHighContrast);
    }

    // Init
    function init() {
      isHighContrast = localStorage.getItem('wellnessGridHighContrast') === 'true';
      document.body.classList.toggle('high-contrast', isHighContrast);
      loadData();

      addHabitBtn.addEventListener('click', addHabit);
      moodEmojis.forEach(emoji => {
        emoji.addEventListener('click', () => logMood(emoji.textContent));
        emoji.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            logMood(emoji.textContent);
          }
        });
      });
      exportBtn.addEventListener('click', exportDataToJson);
      importBtn.addEventListener('click', importDataFromJson);
      contrastToggle.addEventListener('click', toggleContrast);

      // Global drop handler for grid
      grid.addEventListener('dragover', (e) => e.preventDefault());
      grid.addEventListener('drop', (e) => {
        e.preventDefault();
        if (draggedTile) {
          const newIndex = [...grid.children].indexOf(draggedTile);
          if (newIndex !== draggedIndex) {
            const [moved] = habits.splice(draggedIndex, 1);
            habits.splice(newIndex, 0, moved);
            saveData();
            renderGrid();
          }
        }
      });
    }

    init();
  </script>
</body>
</html>