<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-07T13:26:33.000675Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sensor Snapshot</title>
<style>
  :root {
    --color-bg-light: #fff;
    --color-text-light: #222;
    --color-bg-dark: #121212;
    --color-text-dark: #eee;
    --color-line-today: #1f77b4;
    --color-line-yesterday: #ff7f0e;
    --color-line-today-mono: #000;
    --color-line-yesterday-mono: #555;
    --focus-outline: 2px solid #06f;
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  @media (prefers-color-scheme: dark) {
    :root {
      background: var(--color-bg-dark);
      color: var(--color-text-dark);
    }
    body {
      background: var(--color-bg-dark);
      color: var(--color-text-dark);
    }
  }
  @media (prefers-color-scheme: light) {
    :root {
      background: var(--color-bg-light);
      color: var(--color-text-light);
    }
    body {
      background: var(--color-bg-light);
      color: var(--color-text-light);
    }
  }
  body {
    margin: 0;
    font-family: var(--font-family);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    line-height: 1.4;
  }
  header, footer {
    padding: 0.5em 1em;
    background: #eee;
    color: #222;
    font-size: 0.9rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  @media (prefers-color-scheme: dark) {
    header, footer {
      background: #222;
      color: #eee;
    }
  }
  main {
    flex: 1 0 auto;
    padding: 1em;
    max-width: 900px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
  }
  label {
    font-weight: 600;
  }
  input[type="text"] {
    font-size: 1rem;
    padding: 0.3em 0.5em;
    margin-left: 0.5em;
    border: 1px solid #888;
    border-radius: 3px;
  }
  input[type="text"]:focus {
    outline: var(--focus-outline);
    border-color: #06f;
  }
  #location-form {
    margin-bottom: 1em;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
  #location-error {
    color: #c00;
    font-size: 0.9rem;
    margin-left: 0.5em;
  }
  #chart-container {
    position: relative;
    width: 100%;
    flex-grow: 1;
    min-height: 300px;
  }
  canvas {
    width: 100% !important;
    height: auto !important;
    max-height: 400px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: transparent;
  }
  #legend {
    margin-top: 0.5em;
    display: flex;
    gap: 1em;
    flex-wrap: wrap;
  }
  .legend-item {
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 0.3em;
    font-size: 1rem;
  }
  .legend-color {
    width: 1em;
    height: 1em;
    border-radius: 2px;
    border: 1px solid #666;
  }
  .legend-item[aria-pressed="true"] .legend-color {
    box-shadow: 0 0 3px 2px #06f;
  }
  .legend-item:focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  button {
    font-size: 1rem;
    padding: 0.3em 0.7em;
    margin-left: 1em;
    cursor: pointer;
    border-radius: 3px;
    border: 1px solid #666;
    background: transparent;
    color: inherit;
  }
  button:focus-visible {
    outline: var(--focus-outline);
  }
  #status-bar {
    font-size: 0.9rem;
    margin-top: 0.8em;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 0.5em;
  }
  #help-tooltip {
    position: fixed;
    top: 1em;
    right: 1em;
    background: #f9f9f9;
    color: #222;
    border: 1px solid #888;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    max-width: 320px;
    padding: 1em;
    font-size: 0.9rem;
    z-index: 1000;
  }
  #help-tooltip.dark {
    background: #222;
    color: #eee;
    border-color: #555;
  }
  #help-tooltip button {
    margin-top: 0.5em;
    float: right;
  }
  #live-region {
    position: absolute;
    left: -9999px;
    width: 1px;
    height: 1px;
    overflow: hidden;
  }
  @media print {
    body {
      background: #fff !important;
      color: #000 !important;
    }
    #chart-container canvas {
      max-height: none !important;
      height: 400px !important;
      border-color: #000 !important;
    }
    #legend {
      order: 2;
      margin-top: 1em;
      justify-content: center;
      gap: 2em;
    }
    .legend-color {
      border-color: #000 !important;
    }
    .legend-item .legend-color {
      background: none !important;
      border-style: dashed !important;
    }
    .legend-item.today .legend-color {
      border-color: #000 !important;
    }
    .legend-item.yesterday .legend-color {
      border-color: #555 !important;
    }
    #print-watermark {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-45deg);
      font-size: 6rem;
      color: rgba(0,0,0,0.1);
      pointer-events: none;
      user-select: none;
      z-index: 9999;
      font-weight: 900;
      font-family: var(--font-family);
    }
    #help-tooltip, #location-form, button, #status-bar {
      display: none !important;
    }
  }
</style>
</head>
<body>
<header>
  <form id="location-form" aria-label="Location selection">
    <label for="location-input" id="location-label">Location:</label>
    <input type="text" id="location-input" aria-labelledby="location-label" aria-describedby="location-error" autocomplete="off" />
    <span id="location-error" role="alert" aria-live="assertive"></span>
    <button type="submit" id="submit-location" aria-label="Set location">Set</button>
  </form>
  <button id="export-png" aria-label="Export chart as PNG image">Export PNG</button>
</header>
<main>
  <section aria-label="Sensor data comparison chart" role="region" tabindex="0" id="chart-container">
    <canvas id="sensor-chart" aria-describedby="chart-desc" role="img" aria-live="polite"></canvas>
    <div id="live-region" aria-live="polite" aria-atomic="true"></div>
    <p id="chart-desc" hidden>Line chart comparing today's and yesterday's sensor readings for temperature and humidity over 24 hours.</p>
  </section>
  <nav id="legend" role="list" aria-label="Chart legend">
    <div class="legend-item today" role="button" tabindex="0" aria-pressed="true" data-day="today" aria-label="Toggle today's data line">
      <span class="legend-color" style="background-color: var(--color-line-today)"></span> Today
    </div>
    <div class="legend-item yesterday" role="button" tabindex="0" aria-pressed="true" data-day="yesterday" aria-label="Toggle yesterday's data line">
      <span class="legend-color" style="background-color: var(--color-line-yesterday)"></span> Yesterday
    </div>
  </nav>
</main>
<footer id="status-bar" aria-live="polite" aria-atomic="true">
  <div id="status-time">Time: --:--:-- UTC</div>
  <div id="status-location">Location: --</div>
  <div id="status-refresh">Data refreshed: --</div>
</footer>
<div id="help-tooltip" role="dialog" aria-modal="true" aria-labelledby="help-title" tabindex="0" hidden>
  <h2 id="help-title">Keyboard Shortcuts</h2>
  <ul>
    <li><strong>Tab</strong>: Navigate through location input, chart, and legend</li>
    <li><strong>Enter / Space</strong>: Toggle visibility of today's or yesterday's data line in the legend</li>
    <li><strong>Arrow Left / Right</strong>: Pan chart horizontally if zoomed</li>
  </ul>
  <button id="dismiss-help" aria-label="Dismiss help tooltip">Dismiss</button>
</div>
<div id="print-watermark" aria-hidden="true">Print View</div>
<script>
(() => {
  "use strict";

  // I18n placeholders
  const i18n = {
    locationLabel: "Location:",
    setLocation: "Set",
    exportPNG: "Export PNG",
    today: "Today",
    yesterday: "Yesterday",
    toggleToday: "Toggle today's data line",
    toggleYesterday: "Toggle yesterday's data line",
    keyboardHelpTitle: "Keyboard Shortcuts",
    keyboardHelpContent: [
      "Tab: Navigate through location input, chart, and legend",
      "Enter / Space: Toggle visibility of today's or yesterday's data line in the legend",
      "Arrow Left / Right: Pan chart horizontally if zoomed"
    ],
    dismissHelp: "Dismiss",
    statusTime: "Time",
    statusLocation: "Location",
    statusRefresh: "Data refreshed",
    invalidLocation: "Invalid location. Please enter 1-30 alphanumeric characters, spaces, or -/_ only."
  };

  // DOM references
  const locationForm = document.getElementById("location-form");
  const locationInput = document.getElementById("location-input");
  const locationError = document.getElementById("location-error");
  const legend = document.getElementById("legend");
  const todayLegendItem = legend.querySelector('.legend-item.today');
  const yesterdayLegendItem = legend.querySelector('.legend-item.yesterday');
  const chartContainer = document.getElementById("chart-container");
  const canvas = document.getElementById("sensor-chart");
  const ctx = canvas.getContext("2d");
  const liveRegion = document.getElementById("live-region");
  const statusTime = document.getElementById("status-time");
  const statusLocation = document.getElementById("status-location");
  const statusRefresh = document.getElementById("status-refresh");
  const exportBtn = document.getElementById("export-png");
  const helpTooltip = document.getElementById("help-tooltip");
  const dismissHelpBtn = document.getElementById("dismiss-help");
  const printWatermark = document.getElementById("print-watermark");

  // Constants
  const STORAGE_KEY_LOCATION = "sensorSnapshotLocation";
  const STORAGE_KEY_HELP_DISMISSED = "sensorSnapshotHelpDismissed";
  const MAX_LOCATION_LENGTH = 30;
  const MIN_LOCATION_LENGTH = 1;

  // Chart data and state
  let location = "Home";
  let dataToday = [];
  let dataYesterday = [];
  let showToday = true;
  let showYesterday = true;
  let chartWidth = 0;
  let chartHeight = 0;
  let panOffset = 0; // in minutes, 0 means showing full 24h from 0 to 24h
  let zoomLevel = 1; // 1 means full 24h, >1 means zoomed in
  const maxZoom = 6; // max 4h window
  const minZoom = 1; // full 24h
  const dataPointsCount = 48; // half-hour intervals for 24h

  // Accessibility helpers
  function announceLive(text) {
    liveRegion.textContent = "";
    setTimeout(() => {
      liveRegion.textContent = text;
    }, 100);
  }

  // Validate location input
  function validateLocationInput(value) {
    // Allow letters, numbers, spaces, dash, underscore, 1-30 chars
    const valid = /^[\w\s\-]{1,30}$/.test(value.trim());
    return valid;
  }

  // Save location to localStorage
  function saveLocation(loc) {
    try {
      localStorage.setItem(STORAGE_KEY_LOCATION, loc);
      return true;
    } catch {
      return false;
    }
  }

  // Load location from localStorage
  function loadLocation() {
    try {
      const loc = localStorage.getItem(STORAGE_KEY_LOCATION);
      if (loc && validateLocationInput(loc)) return loc;
    } catch {}
    return null;
  }

  // Save help dismissed state
  function saveHelpDismissed() {
    try {
      localStorage.setItem(STORAGE_KEY_HELP_DISMISSED, "true");
    } catch {}
  }

  // Load help dismissed state
  function loadHelpDismissed() {
    try {
      return localStorage.getItem(STORAGE_KEY_HELP_DISMISSED) === "true";
    } catch {
      return false;
    }
  }

  // Generate simulated sensor data for 24h with half-hour intervals
  // Simulates temperature and humidity with morning dip, afternoon peak, evening drop
  // Returns array of objects: {time: Date, temperature: number, humidity: number}
  function generateSensorData(baseDate) {
    const data = [];
    // baseDate is UTC midnight start of day
    for (let i = 0; i < dataPointsCount; i++) {
      const minutes = i * 30;
      const time = new Date(baseDate.getTime() + minutes * 60000);
      // Temperature pattern (°C): low ~15 at 6am, peak ~25 at 15pm, evening drop ~18 at 21pm
      // Use sine wave + noise
      const hour = time.getUTCHours() + time.getUTCMinutes() / 60;
      // Map hour 0-24 to angle 0-2π, peak at 15h (3pm)
      const angle = ((hour - 3) / 24) * 2 * Math.PI;
      const tempBase = 20 + 7 * Math.sin(angle);
      const temperature = +(tempBase + (Math.random() - 0.5) * 1.5).toFixed(1);
      // Humidity pattern (%): high ~80 at 6am, low ~40 at 15pm, moderate ~60 at 21pm
      const humBase = 60 - 20 * Math.sin(angle);
      const humidity = Math.min(100, Math.max(20, +(humBase + (Math.random() - 0.5) * 5).toFixed(0)));
      data.push({ time, temperature, humidity });
    }
    return data;
  }

  // Format time as HH:MM UTC
  function formatTimeUTC(date) {
    return date.toISOString().slice(11, 16);
  }

  // Format date/time for status bar refresh timestamp
  function formatDateTimeUTC(date) {
    return date.toISOString().replace("T", " ").slice(0, 19) + " UTC";
  }

  // Draw chart with current data and visibility state
  function drawChart() {
    const dpr = window.devicePixelRatio || 1;
    chartWidth = chartContainer.clientWidth;
    chartHeight = Math.min(400, window.innerHeight * 0.5);
    canvas.width = chartWidth * dpr;
    canvas.height = chartHeight * dpr;
    canvas.style.width = chartWidth + "px";
    canvas.style.height = chartHeight + "px";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, chartWidth, chartHeight);

    // Margins
    const margin = { top: 30, right: 60, bottom: 40, left: 50 };
    const w = chartWidth - margin.left - margin.right;
    const h = chartHeight - margin.top - margin.bottom;

    // Draw axes
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 1;
    ctx.font = "12px sans-serif";
    ctx.fillStyle = getComputedStyle(document.body).color;

    // Y axis left: Temperature °C
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + h);
    ctx.stroke();
    ctx.fillText("Temperature (°C)", 5, margin.top + 12);

    // Y axis right: Humidity %
    ctx.beginPath();
    ctx.moveTo(margin.left + w, margin.top);
    ctx.lineTo(margin.left + w, margin.top + h);
    ctx.stroke();
    ctx.fillText("Humidity (%)", margin.left + w + 5, margin.top + 12);

    // X axis bottom: time labels every 4h
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top + h);
    ctx.lineTo(margin.left + w, margin.top + h);
    ctx.stroke();

    // Time range depends on zoom and pan
    // total minutes visible = 24h / zoomLevel
    const totalMinutesVisible = 24 * 60 / zoomLevel;
    // panOffset in minutes from 0 (midnight) to max (24h - visible window)
    const maxPan = 24 * 60 - totalMinutesVisible;
    if (panOffset < 0) panOffset = 0;
    if (panOffset > maxPan) panOffset = maxPan;

    // X scale: minutes to pixels
    const xScale = w / totalMinutesVisible;

    // Draw vertical grid lines and time labels every 4h or less depending on zoom
    const labelIntervalMinutes = 240; // 4h
    for (let m = 0; m <= 24 * 60; m += labelIntervalMinutes) {
      if (m < panOffset || m > panOffset + totalMinutesVisible) continue;
      const x = margin.left + (m - panOffset) * xScale;
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, margin.top + h);
      ctx.stroke();
      ctx.fillStyle = getComputedStyle(document.body).color;
      ctx.textAlign = "center";
      ctx.fillText(
        `${String(Math.floor(m / 60)).padStart(2, "0")}:00`,
        x,
        margin.top + h + 15
      );
    }

    // Y scale temperature: min 10°C to max 30°C
    const tempMin = 10;
    const tempMax = 30;
    const tempScale = h / (tempMax - tempMin);

    // Y scale humidity: 20% to 100%
    const humMin = 20;
    const humMax = 100;
    const humScale = h / (humMax - humMin);

    // Helper to get x pixel for time
    function getX(time) {
      const minutes = time.getUTCHours() * 60 + time.getUTCMinutes();
      return margin.left + (minutes - panOffset) * xScale;
    }
    // Helper to get y pixel for temperature
    function getYTemp(temp) {
      return margin.top + h - (temp - tempMin) * tempScale;
    }
    // Helper to get y pixel for humidity
    function getYHum(hum) {
      return margin.top + h - (hum - humMin) * humScale;
    }

    // Draw lines for temperature and humidity for today and yesterday
    // Use distinct colors for today and yesterday, and different line styles for temp/hum
    // On print: monochrome dashed lines

    const isPrint = window.matchMedia("print").matches || window.matchMedia("print").media === "print";

    // Colors
    const colorToday = isPrint ? "black" : getComputedStyle(document.documentElement).getPropertyValue("--color-line-today").trim() || "#1f77b4";
    const colorYesterday = isPrint ? "#555" : getComputedStyle(document.documentElement).getPropertyValue("--color-line-yesterday").trim() || "#ff7f0e";

    // Line styles
    // Temperature: solid line
    // Humidity: dashed line

    // Draw helper function
    function drawLine(data, key, color, visible, dash = []) {
      if (!visible) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dash);
      ctx.beginPath();
      let started = false;
      for (let i = 0; i < data.length; i++) {
        const pt = data[i];
        const x = getX(pt.time);
        if (x < margin.left || x > margin.left + w) continue;
        const y = key === "temperature" ? getYTemp(pt.temperature) : getYHum(pt.humidity);
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw lines
    drawLine(dataToday, "temperature", colorToday, showToday, []);
    drawLine(dataToday, "humidity", colorToday, showToday, [6, 4]);
    drawLine(dataYesterday, "temperature", colorYesterday, showYesterday, []);
    drawLine(dataYesterday, "humidity", colorYesterday, showYesterday, [6, 4]);

    // Draw legend markers on chart top-left
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "left";
    ctx.fillStyle = colorToday;
    if (showToday) {
      ctx.fillText("Today", margin.left, margin.top - 10);
    }
    ctx.fillStyle = colorYesterday;
    if (showYesterday) {
      ctx.fillText("Yesterday", margin.left + 80, margin.top - 10);
    }
  }

  // Generate data for today and yesterday (UTC midnight base)
  function generateDataSets() {
    const now = new Date();
    const utcMidnightToday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    const utcMidnightYesterday = new Date(utcMidnightToday.getTime() - 24 * 3600 * 1000);
    dataToday = generateSensorData(utcMidnightToday);
    dataYesterday = generateSensorData(utcMidnightYesterday);
  }

  // Update status bar
  function updateStatusBar() {
    const now = new Date();
    statusTime.textContent = `${i18n.statusTime}: ${formatTimeUTC(now)} UTC`;
    statusLocation.textContent = `${i18n.statusLocation}: ${location}`;
    statusRefresh.textContent = `${i18n.statusRefresh}: ${formatDateTimeUTC(now)}`;
  }

  // Toggle legend item visibility
  function toggleLegend(day) {
    if (day === "today") {
      showToday = !showToday;
      todayLegendItem.setAttribute("aria-pressed", showToday.toString());
    } else if (day === "yesterday") {
      showYesterday = !showYesterday;
      yesterdayLegendItem.setAttribute("aria-pressed", showYesterday.toString());
    }
    drawChart();
    announceLive(`${day === "today" ? i18n.today : i18n.yesterday} line ${day === "today" ? (showToday ? "shown" : "hidden") : (showYesterday ? "shown" : "hidden")}`);
  }

  // Keyboard handlers for legend toggling and chart panning
  function onLegendKeyDown(e) {
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      const day = e.currentTarget.dataset.day;
      toggleLegend(day);
    }
  }

  function onChartKeyDown(e) {
    if (zoomLevel > 1) {
      if (e.key === "ArrowLeft") {
        e.preventDefault();
        panOffset = Math.max(0, panOffset - 30);
        drawChart();
        announceLive("Chart panned left");
      } else if (e.key === "ArrowRight") {
        e.preventDefault();
        const maxPan = 24 * 60 - 24 * 60 / zoomLevel;
        panOffset = Math.min(maxPan, panOffset + 30);
        drawChart();
        announceLive("Chart panned right");
      }
    }
  }

  // Export canvas as PNG
  function exportPNG() {
    try {
      const link = document.createElement("a");
      link.download = `sensor_snapshot_${location.replace(/\s+/g, "_")}_${new Date().toISOString().slice(0,10)}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    } catch {
      alert("Export failed.");
    }
  }

  // Handle location form submit
  function onLocationSubmit(e) {
    e.preventDefault();
    const val = locationInput.value.trim();
    if (!validateLocationInput(val)) {
      locationError.textContent = i18n.invalidLocation;
      locationInput.setAttribute("aria-invalid", "true");
      return;
    }
    locationError.textContent = "";
    locationInput.removeAttribute("aria-invalid");
    location = val;
    if (!saveLocation(location)) {
      locationError.textContent = "Warning: Failed to save location.";
    }
    updateStatusBar();
    announceLive(`Location set to ${location}`);
  }

  // Initialize app
  function init() {
    // Load location from storage or default
    const storedLoc = loadLocation();
    location = storedLoc || "Home";
    locationInput.value = location;
    updateStatusBar();

    // Generate data sets
    generateDataSets();

    // Draw chart initially
    drawChart();

    // Setup legend event listeners
    todayLegendItem.addEventListener("click", () => toggleLegend("today"));
    yesterdayLegendItem.addEventListener("click", () => toggleLegend("yesterday"));
    todayLegendItem.addEventListener("keydown", onLegendKeyDown);
    yesterdayLegendItem.addEventListener("keydown", onLegendKeyDown);

    // Setup chart keyboard navigation
    chartContainer.addEventListener("keydown", onChartKeyDown);

    // Setup location form submit
    locationForm.addEventListener("submit", onLocationSubmit);

    // Setup export button
    exportBtn.addEventListener("click", exportPNG);

    // Setup help tooltip
    if (!loadHelpDismissed()) {
      showHelpTooltip();
    }

    dismissHelpBtn.addEventListener("click", () => {
      hideHelpTooltip();
      saveHelpDismissed();
    });

    // Update time every second
    setInterval(() => {
      updateStatusBar();
    }, 1000);

    // Responsive redraw on resize
    window.addEventListener("resize", () => {
      drawChart();
    });

    // Print media listener for redraw
    window.matchMedia("print").addEventListener("change", e => {
      drawChart();
    });
  }

  // Show help tooltip
  function showHelpTooltip() {
    helpTooltip.hidden = false;
    if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
      helpTooltip.classList.add("dark");
    } else {
      helpTooltip.classList.remove("dark");
    }
    helpTooltip.focus();
  }

  // Hide help tooltip
  function hideHelpTooltip() {
    helpTooltip.hidden = true;
  }

  // Initialize on DOM ready
  document.addEventListener("DOMContentLoaded", init);
})();
</script>
</body>
</html>