<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-06T13:30:11.137296Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ChronoList: Time-Stamped Daily Task Tracker</title>
<style>
  :root {
    --color-bg: #fff;
    --color-text: #222;
    --color-accent: #0078d7;
    --color-complete-bg: #d0f0d0;
    --color-complete-text: #2a6a2a;
    --color-border: #ccc;
    --color-focus: #005a9e;
    --color-header-bg: #f0f0f0;
    --color-header-border: #bbb;
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  body {
    margin: 0;
    font-family: var(--font-family);
    background: var(--color-bg);
    color: var(--color-text);
    line-height: 1.4;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    background: var(--color-accent);
    color: white;
    padding: 0.5em 1em;
    font-weight: 600;
    font-size: 1.25rem;
    user-select: none;
  }
  main {
    flex: 1 1 auto;
    overflow-y: auto;
    padding: 0.5em 1em 1em 1em;
  }
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
    margin-bottom: 0.75em;
  }
  #new-task-input {
    flex: 1 1 100%;
    display: flex;
    gap: 0.5em;
  }
  #task-text {
    flex: 1 1 auto;
    font-size: 1rem;
    padding: 0.3em 0.5em;
    border: 1px solid var(--color-border);
    border-radius: 3px;
  }
  #task-time {
    width: 6.5em;
    padding: 0.3em 0.5em;
    font-size: 1rem;
    border: 1px solid var(--color-border);
    border-radius: 3px;
  }
  button {
    background: var(--color-accent);
    color: white;
    border: none;
    border-radius: 3px;
    padding: 0.3em 0.7em;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
  }
  button:disabled {
    background: #999;
    cursor: default;
  }
  button:focus-visible {
    outline: 2px solid var(--color-focus);
    outline-offset: 2px;
  }
  #filter-bar {
    display: flex;
    gap: 0.5em;
    flex-wrap: wrap;
    margin-bottom: 0.75em;
  }
  #filter-date, #filter-keyword {
    padding: 0.3em 0.5em;
    font-size: 1rem;
    border: 1px solid var(--color-border);
    border-radius: 3px;
  }
  #task-list {
    position: relative;
  }
  .day-group {
    margin-bottom: 1.5em;
  }
  .day-header {
    position: sticky;
    top: 0;
    background: var(--color-header-bg);
    border-bottom: 1px solid var(--color-header-border);
    padding: 0.3em 0.5em;
    font-weight: 700;
    font-size: 1.1rem;
    z-index: 10;
  }
  ul.tasks {
    list-style: none;
    margin: 0.3em 0 0 0;
    padding: 0;
  }
  li.task {
    display: flex;
    align-items: center;
    gap: 0.5em;
    padding: 0.25em 0.4em;
    border-bottom: 1px solid var(--color-border);
  }
  li.task:last-child {
    border-bottom: none;
  }
  li.task.completed {
    background: var(--color-complete-bg);
    color: var(--color-complete-text);
    text-decoration: line-through;
  }
  li.task[aria-selected="true"] {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }
  .task-time {
    width: 5.5em;
    font-family: monospace;
    font-size: 0.9rem;
    color: #555;
    user-select: none;
  }
  .task-checkbox {
    flex-shrink: 0;
    width: 1.2em;
    height: 1.2em;
    cursor: pointer;
  }
  .task-text {
    flex: 1 1 auto;
    font-size: 1rem;
    cursor: text;
    min-width: 0;
  }
  .task-text[contenteditable="true"] {
    border-bottom: 1px solid var(--color-accent);
    outline: none;
  }
  .task-note {
    font-size: 0.85rem;
    color: #666;
    font-style: italic;
    margin-left: 0.5em;
    flex-shrink: 0;
    max-width: 30vw;
    overflow-wrap: break-word;
  }
  .task-actions {
    display: flex;
    gap: 0.3em;
    flex-shrink: 0;
  }
  .task-button {
    background: transparent;
    border: none;
    color: var(--color-accent);
    cursor: pointer;
    font-size: 1.1rem;
    line-height: 1;
    padding: 0 0.2em;
    user-select: none;
  }
  .task-button:focus-visible {
    outline: 2px solid var(--color-focus);
    outline-offset: 2px;
  }
  .hidden {
    display: none !important;
  }
  #import-file {
    display: none;
  }
  @media (max-width: 600px) {
    .task-note {
      max-width: 50vw;
    }
    #task-time {
      width: 5.5em;
    }
  }
</style>
</head>
<body>
<header role="banner" aria-label="ChronoList Task Tracker">
  ChronoList: Time-Stamped Daily Task Tracker
</header>
<main role="main" aria-live="polite" aria-atomic="false">
  <section id="controls" aria-label="Add new task">
    <form id="new-task-input" aria-describedby="new-task-desc">
      <input type="time" id="task-time" aria-label="Task time (optional)" step="60" />
      <input type="text" id="task-text" aria-label="New task description" placeholder="Add new task..." autocomplete="off" required />
      <button type="submit" aria-label="Add task">Add</button>
    </form>
    <div id="new-task-desc" class="hidden">Enter a time (optional) and task description, then press Add or Enter to create a new task.</div>
  </section>
  <section id="filter-bar" aria-label="Filter tasks">
    <input type="date" id="filter-date" aria-label="Filter by date" />
    <input type="search" id="filter-keyword" aria-label="Search tasks by keyword" placeholder="Search tasks..." autocomplete="off" />
    <button id="undo-btn" aria-label="Undo last action" disabled>Undo (Ctrl+Z)</button>
    <button id="redo-btn" aria-label="Redo last undone action" disabled>Redo (Ctrl+Y)</button>
    <button id="export-btn" aria-label="Export tasks as JSON">Export JSON</button>
    <button id="import-btn" aria-label="Import tasks from JSON">Import JSON</button>
    <input type="file" id="import-file" accept="application/json" aria-hidden="true" />
  </section>
  <section id="task-list" tabindex="0" aria-label="Task list grouped by day">
    <!-- Day groups and tasks inserted here -->
  </section>
</main>
<script>
(() => {
  "use strict";

  // Data model:
  // tasks: array of {id:string, timestamp:string|null(ISO time), text:string, note:string, completed:boolean, date:string(YYYY-MM-DD)}
  // date is UTC date string derived from timestamp or current date if no timestamp

  // Undo/Redo stacks store snapshots of tasks array
  // To optimize, we store diffs, but here for simplicity store full snapshots

  // Utilities
  const $ = (s, ctx = document) => ctx.querySelector(s);
  const $$ = (s, ctx = document) => Array.from(ctx.querySelectorAll(s));
  const utcDateStr = (date) => date.toISOString().slice(0, 10);
  const parseTimeToISO = (timeStr, dateStr) => {
    // timeStr "HH:MM" or ""
    if (!timeStr) return null;
    // Compose ISO string in UTC for given date and time
    // Date is YYYY-MM-DD, time HH:MM
    // Return ISO string with "Z"
    const [h, m] = timeStr.split(":").map(Number);
    const d = new Date(dateStr + "T00:00:00Z");
    d.setUTCHours(h, m, 0, 0);
    return d.toISOString();
  };
  const generateId = () =>
    "id-" +
    Math.random().toString(36).slice(2) +
    "-" +
    Date.now().toString(36);

  // State
  let tasks = [];
  let undoStack = [];
  let redoStack = [];

  // Filter state
  let filterDate = "";
  let filterKeyword = "";

  // Focus and selection state
  let selectedTaskId = null;

  // DOM Elements
  const taskListEl = $("#task-list");
  const newTaskForm = $("#new-task-input");
  const taskTextInput = $("#task-text");
  const taskTimeInput = $("#task-time");
  const filterDateInput = $("#filter-date");
  const filterKeywordInput = $("#filter-keyword");
  const undoBtn = $("#undo-btn");
  const redoBtn = $("#redo-btn");
  const exportBtn = $("#export-btn");
  const importBtn = $("#import-btn");
  const importFileInput = $("#import-file");

  // Save/load from localStorage
  const STORAGE_KEY = "chronolist-tasks";

  function saveState() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
  }
  function loadState() {
    const data = localStorage.getItem(STORAGE_KEY);
    if (data) {
      try {
        const parsed = JSON.parse(data);
        if (Array.isArray(parsed)) {
          tasks = parsed;
          return true;
        }
      } catch {}
    }
    return false;
  }

  // Undo/Redo helpers
  function pushUndo() {
    undoStack.push(JSON.stringify(tasks));
    if (undoStack.length > 100) undoStack.shift();
    redoStack = [];
    updateUndoRedoButtons();
  }
  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(JSON.stringify(tasks));
    const prev = undoStack.pop();
    tasks = JSON.parse(prev);
    saveState();
    render();
    updateUndoRedoButtons();
  }
  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(JSON.stringify(tasks));
    const next = redoStack.pop();
    tasks = JSON.parse(next);
    saveState();
    render();
    updateUndoRedoButtons();
  }
  function updateUndoRedoButtons() {
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  // Task operations
  function addTask(timeStr, text) {
    if (!text.trim()) return;
    const now = new Date();
    const dateStr = utcDateStr(now);
    const timestamp = parseTimeToISO(timeStr, dateStr);
    const taskDate = timestamp ? utcDateStr(new Date(timestamp)) : dateStr;
    const newTask = {
      id: generateId(),
      timestamp: timestamp,
      text: text.trim(),
      note: "",
      completed: false,
      date: taskDate,
    };
    pushUndo();
    tasks.push(newTask);
    tasks.sort(taskCompare);
    saveState();
    render();
    selectTask(newTask.id);
  }
  function editTask(id, newText, newNote) {
    const idx = tasks.findIndex((t) => t.id === id);
    if (idx === -1) return;
    pushUndo();
    tasks[idx].text = newText.trim();
    tasks[idx].note = newNote.trim();
    saveState();
    render();
    selectTask(id);
  }
  function deleteTask(id) {
    const idx = tasks.findIndex((t) => t.id === id);
    if (idx === -1) return;
    pushUndo();
    tasks.splice(idx, 1);
    saveState();
    render();
    selectedTaskId = null;
  }
  function toggleComplete(id) {
    const idx = tasks.findIndex((t) => t.id === id);
    if (idx === -1) return;
    pushUndo();
    tasks[idx].completed = !tasks[idx].completed;
    saveState();
    render();
    selectTask(id);
  }
  function taskCompare(a, b) {
    // Sort by date ascending, then timestamp ascending (null last), then id
    if (a.date < b.date) return -1;
    if (a.date > b.date) return 1;
    if (a.timestamp === b.timestamp) {
      return a.id < b.id ? -1 : 1;
    }
    if (a.timestamp === null) return 1;
    if (b.timestamp === null) return -1;
    return a.timestamp < b.timestamp ? -1 : 1;
  }

  // Rendering
  function render() {
    // Filter tasks by date and keyword
    let filtered = tasks;
    if (filterDate) {
      filtered = filtered.filter((t) => t.date === filterDate);
    }
    if (filterKeyword) {
      const kw = filterKeyword.toLowerCase();
      filtered = filtered.filter(
        (t) =>
          t.text.toLowerCase().includes(kw) ||
          (t.note && t.note.toLowerCase().includes(kw))
      );
    }
    // Group by date
    const groups = {};
    for (const t of filtered) {
      if (!groups[t.date]) groups[t.date] = [];
      groups[t.date].push(t);
    }
    // Sort dates ascending
    const sortedDates = Object.keys(groups).sort();

    // Clear
    taskListEl.innerHTML = "";

    if (sortedDates.length === 0) {
      const emptyMsg = document.createElement("p");
      emptyMsg.textContent = "No tasks found.";
      taskListEl.appendChild(emptyMsg);
      return;
    }

    // Render each day group
    for (const date of sortedDates) {
      const dayGroup = document.createElement("section");
      dayGroup.className = "day-group";
      dayGroup.setAttribute("aria-label", `Tasks for ${date}`);

      const dayHeader = document.createElement("h2");
      dayHeader.className = "day-header";
      dayHeader.textContent = date;
      dayGroup.appendChild(dayHeader);

      const ul = document.createElement("ul");
      ul.className = "tasks";
      ul.setAttribute("role", "list");

      for (const t of groups[date]) {
        const li = document.createElement("li");
        li.className = "task";
        li.setAttribute("role", "listitem");
        li.setAttribute("tabindex", "-1");
        li.dataset.id = t.id;
        if (t.completed) li.classList.add("completed");
        if (t.id === selectedTaskId) {
          li.setAttribute("aria-selected", "true");
          li.tabIndex = 0;
        } else {
          li.removeAttribute("aria-selected");
        }

        // Checkbox
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "task-checkbox";
        checkbox.checked = t.completed;
        checkbox.setAttribute("aria-label", t.completed ? "Mark incomplete" : "Mark complete");
        checkbox.tabIndex = -1;
        checkbox.addEventListener("change", (e) => {
          e.stopPropagation();
          toggleComplete(t.id);
        });
        li.appendChild(checkbox);

        // Time
        const timeSpan = document.createElement("span");
        timeSpan.className = "task-time";
        timeSpan.textContent = t.timestamp
          ? new Date(t.timestamp).toISOString().slice(11, 16)
          : "";
        li.appendChild(timeSpan);

        // Text editable
        const textSpan = document.createElement("span");
        textSpan.className = "task-text";
        textSpan.textContent = t.text;
        textSpan.tabIndex = -1;
        textSpan.setAttribute("role", "textbox");
        textSpan.setAttribute("aria-label", "Task description");
        textSpan.setAttribute("contenteditable", "false");
        li.appendChild(textSpan);

        // Note editable (optional)
        if (t.note) {
          const noteSpan = document.createElement("span");
          noteSpan.className = "task-note";
          noteSpan.textContent = t.note;
          noteSpan.tabIndex = -1;
          noteSpan.setAttribute("role", "textbox");
          noteSpan.setAttribute("aria-label", "Task note");
          noteSpan.setAttribute("contenteditable", "false");
          li.appendChild(noteSpan);
        }

        // Actions: edit note, delete
        const actions = document.createElement("div");
        actions.className = "task-actions";

        const editBtn = document.createElement("button");
        editBtn.className = "task-button";
        editBtn.title = "Edit task (description and note)";
        editBtn.setAttribute("aria-label", "Edit task");
        editBtn.innerHTML = "âœŽ";
        editBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          startEditingTask(t.id);
        });
        actions.appendChild(editBtn);

        const delBtn = document.createElement("button");
        delBtn.className = "task-button";
        delBtn.title = "Delete task";
        delBtn.setAttribute("aria-label", "Delete task");
        delBtn.innerHTML = "ðŸ—‘";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (confirm("Delete this task?")) {
            deleteTask(t.id);
          }
        });
        actions.appendChild(delBtn);

        li.appendChild(actions);

        // Click to select
        li.addEventListener("click", () => {
          selectTask(t.id);
        });

        ul.appendChild(li);
      }

      dayGroup.appendChild(ul);
      taskListEl.appendChild(dayGroup);
    }
  }

  // Editing state
  let editingTaskId = null;
  function startEditingTask(id) {
    if (editingTaskId !== null) finishEditingTask();
    editingTaskId = id;
    const li = taskListEl.querySelector(`li.task[data-id="${id}"]`);
    if (!li) return;
    const textSpan = li.querySelector(".task-text");
    let noteSpan = li.querySelector(".task-note");
    if (!noteSpan) {
      noteSpan = document.createElement("span");
      noteSpan.className = "task-note";
      noteSpan.textContent = "";
      noteSpan.tabIndex = -1;
      noteSpan.setAttribute("role", "textbox");
      noteSpan.setAttribute("aria-label", "Task note");
      li.insertBefore(noteSpan, li.querySelector(".task-actions"));
    }
    textSpan.setAttribute("contenteditable", "true");
    noteSpan.setAttribute("contenteditable", "true");
    textSpan.focus();
    placeCaretAtEnd(textSpan);
    // Disable keyboard navigation while editing
    taskListEl.removeAttribute("tabindex");
  }
  function finishEditingTask() {
    if (editingTaskId === null) return;
    const li = taskListEl.querySelector(`li.task[data-id="${editingTaskId}"]`);
    if (!li) {
      editingTaskId = null;
      return;
    }
    const textSpan = li.querySelector(".task-text");
    const noteSpan = li.querySelector(".task-note");
    if (!textSpan) {
      editingTaskId = null;
      return;
    }
    const newText = textSpan.textContent.trim();
    const newNote = noteSpan ? noteSpan.textContent.trim() : "";
    if (!newText) {
      // Empty text means delete
      if (confirm("Task description is empty. Delete task?")) {
        deleteTask(editingTaskId);
      } else {
        // Restore previous text from model
        const t = tasks.find((t) => t.id === editingTaskId);
        if (t) {
          textSpan.textContent = t.text;
          if (noteSpan) noteSpan.textContent = t.note;
        }
      }
    } else {
      editTask(editingTaskId, newText, newNote);
    }
    textSpan.setAttribute("contenteditable", "false");
    if (noteSpan) noteSpan.setAttribute("contenteditable", "false");
    editingTaskId = null;
    taskListEl.setAttribute("tabindex", "0");
  }
  function placeCaretAtEnd(el) {
    el.focus();
    if (
      typeof window.getSelection != "undefined" &&
      typeof document.createRange != "undefined"
    ) {
      const range = document.createRange();
      range.selectNodeContents(el);
      range.collapse(false);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }
  }

  // Selection and keyboard navigation
  function selectTask(id) {
    if (selectedTaskId === id) return;
    selectedTaskId = id;
    render();
    focusSelectedTask();
  }
  function focusSelectedTask() {
    if (!selectedTaskId) return;
    const li = taskListEl.querySelector(`li.task[data-id="${selectedTaskId}"]`);
    if (li) li.focus();
  }
  function selectNextTask() {
    const visibleTasks = getVisibleTasks();
    if (visibleTasks.length === 0) return;
    let idx = visibleTasks.findIndex((t) => t.id === selectedTaskId);
    if (idx === -1 || idx === visibleTasks.length - 1) {
      idx = 0;
    } else {
      idx++;
    }
    selectTask(visibleTasks[idx].id);
  }
  function selectPrevTask() {
    const visibleTasks = getVisibleTasks();
    if (visibleTasks.length === 0) return;
    let idx = visibleTasks.findIndex((t) => t.id === selectedTaskId);
    if (idx <= 0) {
      idx = visibleTasks.length - 1;
    } else {
      idx--;
    }
    selectTask(visibleTasks[idx].id);
  }
  function getVisibleTasks() {
    // Filtered tasks in current render order
    let filtered = tasks;
    if (filterDate) {
      filtered = filtered.filter((t) => t.date === filterDate);
    }
    if (filterKeyword) {
      const kw = filterKeyword.toLowerCase();
      filtered = filtered.filter(
        (t) =>
          t.text.toLowerCase().includes(kw) ||
          (t.note && t.note.toLowerCase().includes(kw))
      );
    }
    filtered.sort(taskCompare);
    return filtered;
  }

  // Keyboard shortcuts
  function onKeyDown(e) {
    if (editingTaskId !== null) {
      // Editing mode
      if (e.key === "Escape") {
        // Cancel editing: restore old text
        render();
        editingTaskId = null;
        taskListEl.setAttribute("tabindex", "0");
        e.preventDefault();
      } else if (e.key === "Enter" && !e.shiftKey) {
        finishEditingTask();
        e.preventDefault();
      }
      return;
    }
    if (e.target === taskTextInput || e.target === taskTimeInput) {
      // In new task inputs
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        newTaskForm.requestSubmit();
      }
      return;
    }
    switch (e.key) {
      case "ArrowDown":
        selectNextTask();
        e.preventDefault();
        break;
      case "ArrowUp":
        selectPrevTask();
        e.preventDefault();
        break;
      case " ":
      case "Spacebar":
        // Toggle complete on selected task
        if (selectedTaskId) {
          toggleComplete(selectedTaskId);
          e.preventDefault();
        }
        break;
      case "Enter":
        // Start editing selected task
        if (selectedTaskId) {
          startEditingTask(selectedTaskId);
          e.preventDefault();
        }
        break;
      case "z":
      case "Z":
        if (e.ctrlKey && !e.shiftKey) {
          undo();
          e.preventDefault();
        }
        break;
      case "y":
      case "Y":
        if (e.ctrlKey) {
          redo();
          e.preventDefault();
        }
        break;
      case "n":
      case "N":
        if (e.ctrlKey) {
          taskTextInput.focus();
          e.preventDefault();
        }
        break;
    }
  }

  // Filter handlers
  filterDateInput.addEventListener("input", () => {
    filterDate = filterDateInput.value;
    render();
    selectedTaskId = null;
  });
  filterKeywordInput.addEventListener("input", () => {
    filterKeyword = filterKeywordInput.value.trim();
    render();
    selectedTaskId = null;
  });

  // New task form submit
  newTaskForm.addEventListener("submit", (e) => {
    e.preventDefault();
    addTask(taskTimeInput.value, taskTextInput.value);
    taskTextInput.value = "";
    taskTimeInput.value = "";
    taskTextInput.focus();
  });

  // Undo/Redo buttons
  undoBtn.addEventListener("click", undo);
  redoBtn.addEventListener("click", redo);

  // Export JSON
  exportBtn.addEventListener("click", () => {
    const dataStr = JSON.stringify(tasks, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "chronolist-tasks.json";
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  });

  // Import JSON
  importBtn.addEventListener("click", () => {
    importFileInput.value = "";
    importFileInput.click();
  });
  importFileInput.addEventListener("change", (e) => {
    const file = importFileInput.files;
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const imported = JSON.parse(ev.target.result);
        if (!Array.isArray(imported)) throw new Error("Invalid format");
        // Validate imported tasks minimally
        for (const t of imported) {
          if (
            typeof t.id !== "string" ||
            typeof t.text !== "string" ||
            typeof t.completed !== "boolean" ||
            typeof t.date !== "string"
          )
            throw new Error("Invalid task format");
        }
        // Ask user to merge or replace
        if (
          confirm(
            "Import will merge tasks with existing data. Cancel to replace current tasks."
          )
        ) {
          // Merge: add tasks not already present by id
          pushUndo();
          const existingIds = new Set(tasks.map((t) => t.id));
          for (const t of imported) {
            if (!existingIds.has(t.id)) tasks.push(t);
          }
          tasks.sort(taskCompare);
          saveState();
          render();
        } else {
          // Replace
          pushUndo();
          tasks = imported;
          tasks.sort(taskCompare);
          saveState();
          render();
        }
      } catch (ex) {
        alert("Failed to import JSON: " + ex.message);
      }
    };
    reader.readAsText(file);
  });

  // Auto-scroll to most recent day on load
  function scrollToMostRecentDay() {
    if (tasks.length === 0) return;
    const latestDate = tasks.reduce((a, t) => (t.date > a ? t.date : a), "");
    const dayHeader = taskListEl.querySelector(
      `.day-group > .day-header:contains("${latestDate}")`
    );
    // :contains is not supported, so find manually:
    const headers = $$(".day-header", taskListEl);
    for (const h of headers) {
      if (h.textContent === latestDate) {
        h.scrollIntoView({ block: "start" });
        break;
      }
    }
  }

  // Polyfill for :contains selector (not supported)
  // Instead, use manual search above

  // Initialization
  function init() {
    loadState();
    updateUndoRedoButtons();
    render();
    // Select last task if any
    if (tasks.length > 0) {
      selectedTaskId = tasks[tasks.length - 1].id;
    }
    render();
    focusSelectedTask();
    // Scroll to most recent day
    setTimeout(scrollToMostRecentDay, 50);
  }

  // Global keyboard handler
  document.addEventListener("keydown", onKeyDown);

  // Blur editing on outside click or focus loss
  document.addEventListener("click", (e) => {
    if (editingTaskId !== null) {
      const li = taskListEl.querySelector(`li.task[data-id="${editingTaskId}"]`);
      if (!li) return finishEditingTask();
      if (!li.contains(e.target)) finishEditingTask();
    }
  });
  window.addEventListener("blur", () => {
    if (editingTaskId !== null) finishEditingTask();
  });

  init();
})();  
</script>
</body>
</html>