<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-03T13:29:09.005181Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Research Insight Collector</title>
<style>
  :root {
    --bg: #fff;
    --fg: #222;
    --accent: #007acc;
    --accent-light: #cce6ff;
    --border: #ccc;
    --focus-outline: 2px solid #005a9e;
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    font-family: var(--font-family);
    background: var(--bg);
    color: var(--fg);
    line-height: 1.4;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  header {
    background: var(--accent);
    color: white;
    padding: 1rem 1rem 0.75rem;
    text-align: center;
    font-weight: 600;
    font-size: 1.25rem;
    user-select: none;
  }
  main {
    flex: 1 1 auto;
    display: flex;
    flex-direction: column;
    max-width: 900px;
    margin: 0 auto;
    padding: 0.75rem 1rem 1rem;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem 1rem;
    align-items: center;
    margin-bottom: 1rem;
  }
  label {
    font-weight: 600;
    font-size: 0.9rem;
  }
  input[type="search"],
  input[type="text"],
  select,
  textarea {
    font-family: var(--font-family);
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: 3px;
    background: white;
    color: var(--fg);
    min-width: 150px;
  }
  input[type="search"]:focus,
  input[type="text"]:focus,
  select:focus,
  textarea:focus {
    outline: var(--focus-outline);
    border-color: var(--accent);
    background: var(--accent-light);
  }
  button {
    background: var(--accent);
    border: none;
    color: white;
    padding: 0.4rem 0.75rem;
    border-radius: 3px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    font-size: 1rem;
  }
  button:focus {
    outline: var(--focus-outline);
  }
  button:disabled {
    background: #999;
    cursor: default;
  }
  .notes-container {
    display: grid;
    grid-template-columns: repeat(auto-fill,minmax(280px,1fr));
    gap: 1rem;
  }
  article.note-card {
    background: #f9f9f9;
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 0.75rem 1rem 1rem;
    display: flex;
    flex-direction: column;
    box-shadow: 0 0 3px rgb(0 0 0 / 0.05);
  }
  article.note-card[aria-selected="true"] {
    border-color: var(--accent);
    box-shadow: 0 0 6px var(--accent);
    background: var(--accent-light);
  }
  article.note-card:focus-within {
    outline: var(--focus-outline);
  }
  article.note-card header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.3rem;
  }
  article.note-card header h2 {
    font-size: 1.1rem;
    margin: 0;
    overflow-wrap: break-word;
    flex: 1 1 auto;
  }
  article.note-card header button.delete-btn {
    background: transparent;
    border: none;
    color: #b00;
    font-weight: 700;
    font-size: 1.2rem;
    line-height: 1;
    cursor: pointer;
    padding: 0 0.25rem;
  }
  article.note-card header button.delete-btn:focus {
    outline: var(--focus-outline);
  }
  .tags-list {
    margin: 0.25rem 0 0.5rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
  }
  .tags-list span.tag {
    background: var(--accent);
    color: white;
    font-size: 0.75rem;
    padding: 0.15rem 0.4rem;
    border-radius: 12px;
    user-select: none;
  }
  article.note-card textarea.content {
    flex: 1 1 auto;
    width: 100%;
    border: 1px solid var(--border);
    border-radius: 3px;
    font-family: var(--font-family);
    font-size: 0.9rem;
    resize: vertical;
    min-height: 80px;
    padding: 0.3rem 0.5rem;
    background: white;
    color: var(--fg);
  }
  article.note-card textarea.content:focus {
    outline: var(--focus-outline);
    border-color: var(--accent);
    background: var(--accent-light);
  }
  article.note-card input.title {
    font-weight: 700;
    font-size: 1rem;
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 0.2rem 0.4rem;
    width: 100%;
    margin-bottom: 0.2rem;
    background: white;
    color: var(--fg);
  }
  article.note-card input.title:focus {
    outline: var(--focus-outline);
    border-color: var(--accent);
    background: var(--accent-light);
  }
  .tag-input-container {
    position: relative;
  }
  input.tag-input {
    width: 100%;
    font-size: 0.9rem;
    padding: 0.2rem 0.4rem;
    border: 1px solid var(--border);
    border-radius: 3px;
    background: white;
    color: var(--fg);
  }
  input.tag-input:focus {
    outline: var(--focus-outline);
    border-color: var(--accent);
    background: var(--accent-light);
  }
  ul.autocomplete-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 140px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-top: none;
    background: white;
    z-index: 10;
    margin: 0;
    padding: 0;
    list-style: none;
  }
  ul.autocomplete-list li {
    padding: 0.3rem 0.5rem;
    cursor: pointer;
  }
  ul.autocomplete-list li[aria-selected="true"],
  ul.autocomplete-list li:hover {
    background: var(--accent-light);
  }
  .filter-sort-group {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: center;
  }
  @media (max-width: 600px) {
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
    .filter-sort-group {
      flex-direction: column;
      align-items: stretch;
    }
  }
  /* Focus visible for keyboard users */
  :focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
</style>
</head>
<body>
<header role="banner">Research Insight Collector</header>
<main>
  <section aria-label="Controls" class="controls" role="region">
    <button id="addNoteBtn" aria-label="Add new note (Ctrl+N)">+ Add Note</button>
    <div class="filter-sort-group" role="search" aria-label="Search and filter notes">
      <label for="searchInput">Search:</label>
      <input type="search" id="searchInput" aria-describedby="searchHelp" placeholder="Search notes by title, content, tags" autocomplete="off" />
      <span id="searchHelp" class="sr-only">Type keywords to filter notes in real-time</span>
      <label for="tagFilterInput">Filter by tag:</label>
      <input type="text" id="tagFilterInput" aria-autocomplete="list" aria-haspopup="listbox" aria-expanded="false" aria-owns="tagFilterList" placeholder="Start typing tag" autocomplete="off" />
      <ul id="tagFilterList" role="listbox" tabindex="-1" class="autocomplete-list" hidden></ul>
      <label for="sortSelect">Sort by:</label>
      <select id="sortSelect" aria-label="Sort notes">
        <option value="created_desc">Created (newest first)</option>
        <option value="created_asc">Created (oldest first)</option>
        <option value="modified_desc">Modified (newest first)</option>
        <option value="modified_asc">Modified (oldest first)</option>
      </select>
    </div>
  </section>
  <section aria-label="Notes list" class="notes-container" role="list" id="notesList" tabindex="0"></section>
</main>
<script>
(() => {
  "use strict";

  // Data keys
  const STORAGE_KEY = "ric_notes";
  const STORAGE_UI_KEY = "ric_ui_state";

  // Elements
  const addNoteBtn = document.getElementById("addNoteBtn");
  const searchInput = document.getElementById("searchInput");
  const tagFilterInput = document.getElementById("tagFilterInput");
  const tagFilterList = document.getElementById("tagFilterList");
  const sortSelect = document.getElementById("sortSelect");
  const notesList = document.getElementById("notesList");

  // State
  let notes = [];
  let tagsSet = new Set();
  let filterText = "";
  let filterTag = "";
  let sortOrder = "created_desc";
  let selectedNoteId = null;

  // Utilities
  function generateId() {
    return "n" + Math.random().toString(36).slice(2, 10);
  }
  function nowISO() {
    return new Date().toISOString();
  }
  function escapeHTML(str) {
    return str.replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  }
  // Save/load notes
  function saveNotes() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
  }
  function loadNotes() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      try {
        notes = JSON.parse(raw);
        if(!Array.isArray(notes)) notes = [];
      } catch {
        notes = [];
      }
    }
  }
  // Save/load UI state (filters, sort, selected)
  function saveUIState() {
    const uiState = {
      filterText,
      filterTag,
      sortOrder,
      selectedNoteId
    };
    localStorage.setItem(STORAGE_UI_KEY, JSON.stringify(uiState));
  }
  function loadUIState() {
    const raw = localStorage.getItem(STORAGE_UI_KEY);
    if(raw){
      try {
        const uiState = JSON.parse(raw);
        if(uiState){
          filterText = uiState.filterText || "";
          filterTag = uiState.filterTag || "";
          sortOrder = uiState.sortOrder || "created_desc";
          selectedNoteId = uiState.selectedNoteId || null;
        }
      } catch {}
    }
  }

  // URL hash encode/decode for filter and sort state
  function encodeStateToHash() {
    const params = new URLSearchParams();
    if(filterText) params.set("q", filterText);
    if(filterTag) params.set("tag", filterTag);
    if(sortOrder) params.set("sort", sortOrder);
    location.hash = params.toString();
  }
  function decodeStateFromHash() {
    const hash = location.hash.slice(1);
    const params = new URLSearchParams(hash);
    filterText = params.get("q") || "";
    filterTag = params.get("tag") || "";
    sortOrder = params.get("sort") || "created_desc";
  }

  // Update tagsSet from notes
  function updateTagsSet() {
    tagsSet.clear();
    for(const note of notes){
      if(Array.isArray(note.tags)){
        for(const t of note.tags){
          if(t.trim()) tagsSet.add(t.trim());
        }
      }
    }
  }

  // Filter and sort notes
  function filteredSortedNotes() {
    let filtered = notes.filter(note => {
      const text = (note.title + " " + note.content + " " + (note.tags||[]).join(" ")).toLowerCase();
      const textMatch = filterText.trim() === "" || text.includes(filterText.toLowerCase());
      const tagMatch = filterTag.trim() === "" || (note.tags||[]).some(t => t.toLowerCase() === filterTag.toLowerCase());
      return textMatch && tagMatch;
    });
    filtered.sort((a,b) => {
      let vA, vB;
      switch(sortOrder){
        case "created_asc":
          vA = a.created; vB = b.created; break;
        case "created_desc":
          vA = b.created; vB = a.created; break;
        case "modified_asc":
          vA = a.modified; vB = b.modified; break;
        case "modified_desc":
          vA = b.modified; vB = a.modified; break;
        default:
          vA = b.created; vB = a.created;
      }
      return vA.localeCompare(vB);
    });
    return filtered;
  }

  // Render notes list
  function renderNotes() {
    const filtered = filteredSortedNotes();
    notesList.innerHTML = "";
    if(filtered.length === 0){
      const emptyMsg = document.createElement("p");
      emptyMsg.textContent = "No notes found.";
      emptyMsg.style.fontStyle = "italic";
      notesList.appendChild(emptyMsg);
      return;
    }
    for(const note of filtered){
      const card = createNoteCard(note);
      notesList.appendChild(card);
    }
  }

  // Create note card element
  function createNoteCard(note){
    const article = document.createElement("article");
    article.className = "note-card";
    article.setAttribute("role", "listitem");
    article.setAttribute("tabindex", "-1");
    article.dataset.id = note.id;
    article.setAttribute("aria-selected", note.id === selectedNoteId ? "true" : "false");

    // Header: title + delete button
    const header = document.createElement("header");
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.className = "title";
    titleInput.value = note.title;
    titleInput.setAttribute("aria-label", "Note title");
    titleInput.autocomplete = "off";
    titleInput.spellcheck = false;
    titleInput.addEventListener("input", e => {
      note.title = e.target.value;
      note.modified = nowISO();
      saveNotes();
      updateTagsSet();
      renderNotes();
      saveUIState();
      encodeStateToHash();
    });
    header.appendChild(titleInput);

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "delete-btn";
    delBtn.setAttribute("aria-label", "Delete note");
    delBtn.textContent = "Ã—";
    delBtn.addEventListener("click", e => {
      e.stopPropagation();
      deleteNote(note.id);
    });
    header.appendChild(delBtn);
    article.appendChild(header);

    // Tags display and tag input
    const tagsList = document.createElement("div");
    tagsList.className = "tags-list";
    for(const t of note.tags){
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = t;
      tagsList.appendChild(span);
    }
    article.appendChild(tagsList);

    const tagInputContainer = document.createElement("div");
    tagInputContainer.className = "tag-input-container";
    const tagInput = document.createElement("input");
    tagInput.type = "text";
    tagInput.className = "tag-input";
    tagInput.setAttribute("aria-label", "Add or edit tags (comma separated)");
    tagInput.autocomplete = "off";
    tagInput.spellcheck = false;
    tagInput.value = note.tags.join(", ");
    tagInputContainer.appendChild(tagInput);

    // Autocomplete for tags in tag input
    const autocompleteList = document.createElement("ul");
    autocompleteList.className = "autocomplete-list";
    autocompleteList.setAttribute("role", "listbox");
    autocompleteList.hidden = true;
    tagInputContainer.appendChild(autocompleteList);

    let acSelectedIndex = -1;
    function updateAutocomplete(){
      const val = tagInput.value.toLowerCase();
      const inputTags = val.split(",").map(s => s.trim()).filter(s => s.length > 0);
      const lastFragment = val.endsWith(",") ? "" : inputTags[inputTags.length-1] || "";
      const usedTags = new Set(inputTags);
      const candidates = [...tagsSet].filter(t => t.toLowerCase().startsWith(lastFragment) && !usedTags.has(t));
      autocompleteList.innerHTML = "";
      if(candidates.length === 0){
        autocompleteList.hidden = true;
        tagInput.setAttribute("aria-expanded", "false");
        return;
      }
      candidates.forEach((c,i) => {
        const li = document.createElement("li");
        li.textContent = c;
        li.id = `tag-ac-${note.id}-${i}`;
        li.setAttribute("role", "option");
        li.setAttribute("aria-selected", i === acSelectedIndex ? "true" : "false");
        li.addEventListener("mousedown", e => {
          e.preventDefault();
          selectAutocomplete(c);
        });
        autocompleteList.appendChild(li);
      });
      autocompleteList.hidden = false;
      tagInput.setAttribute("aria-expanded", "true");
    }
    function selectAutocomplete(tag){
      const val = tagInput.value;
      let parts = val.split(",");
      if(val.endsWith(",")){
        parts.push("");
      }
      parts = parts.map(s => s.trim());
      if(parts.length === 0) parts = [""];
      parts[parts.length-1] = tag;
      tagInput.value = parts.filter(s => s.length > 0).join(", ") + ", ";
      autocompleteList.hidden = true;
      tagInput.setAttribute("aria-expanded", "false");
      tagInput.focus();
      acSelectedIndex = -1;
    }
    tagInput.addEventListener("input", e => {
      updateAutocomplete();
    });
    tagInput.addEventListener("keydown", e => {
      if(autocompleteList.hidden) return;
      const items = autocompleteList.querySelectorAll("li");
      if(e.key === "ArrowDown"){
        e.preventDefault();
        acSelectedIndex = (acSelectedIndex + 1) % items.length;
        updateAriaSelected();
      } else if(e.key === "ArrowUp"){
        e.preventDefault();
        acSelectedIndex = (acSelectedIndex - 1 + items.length) % items.length;
        updateAriaSelected();
      } else if(e.key === "Enter"){
        if(acSelectedIndex >= 0 && acSelectedIndex < items.length){
          e.preventDefault();
          selectAutocomplete(items[acSelectedIndex].textContent);
        }
      } else if(e.key === "Escape"){
        autocompleteList.hidden = true;
        tagInput.setAttribute("aria-expanded", "false");
        acSelectedIndex = -1;
      }
      function updateAriaSelected(){
        items.forEach((li,i) => {
          li.setAttribute("aria-selected", i === acSelectedIndex ? "true" : "false");
        });
      }
    });
    tagInput.addEventListener("blur", e => {
      setTimeout(() => {
        autocompleteList.hidden = true;
        tagInput.setAttribute("aria-expanded", "false");
        acSelectedIndex = -1;
      }, 150);
    });
    tagInput.addEventListener("change", e => {
      updateNoteTagsFromInput();
    });
    tagInput.addEventListener("blur", e => {
      updateNoteTagsFromInput();
    });
    function updateNoteTagsFromInput(){
      const val = tagInput.value;
      const newTags = val.split(",").map(s => s.trim()).filter(s => s.length > 0);
      note.tags = Array.from(new Set(newTags));
      note.modified = nowISO();
      saveNotes();
      updateTagsSet();
      renderNotes();
      saveUIState();
      encodeStateToHash();
    }
    article.appendChild(tagInputContainer);

    // Content textarea
    const contentArea = document.createElement("textarea");
    contentArea.className = "content";
    contentArea.setAttribute("aria-label", "Note content");
    contentArea.spellcheck = true;
    contentArea.value = note.content;
    contentArea.addEventListener("input", e => {
      note.content = e.target.value;
      note.modified = nowISO();
      saveNotes();
      renderNotes();
      saveUIState();
      encodeStateToHash();
    });
    article.appendChild(contentArea);

    // Keyboard focus management for note card
    article.addEventListener("click", e => {
      selectNote(note.id);
    });
    article.addEventListener("keydown", e => {
      if(e.key === "Delete" && selectedNoteId === note.id){
        e.preventDefault();
        deleteNote(note.id);
      }
    });

    return article;
  }

  // Add new note
  function addNote(){
    const id = generateId();
    const now = nowISO();
    const newNote = {
      id,
      title: "",
      tags: [],
      content: "",
      created: now,
      modified: now
    };
    notes.push(newNote);
    saveNotes();
    updateTagsSet();
    selectNote(id);
    renderNotes();
    saveUIState();
    encodeStateToHash();
  }
  // Delete note by id
  function deleteNote(id){
    const idx = notes.findIndex(n => n.id === id);
    if(idx >= 0){
      notes.splice(idx, 1);
      if(selectedNoteId === id) selectedNoteId = null;
      saveNotes();
      updateTagsSet();
      renderNotes();
      saveUIState();
      encodeStateToHash();
    }
  }
  // Select note by id
  function selectNote(id){
    if(selectedNoteId === id) return;
    selectedNoteId = id;
    saveUIState();
    encodeStateToHash();
    renderNotes();
    // Focus the note card container for keyboard navigation
    const card = notesList.querySelector(`article.note-card[data-id="${id}"]`);
    if(card) card.focus();
  }

  // Search and filter input handlers
  function onSearchInput(){
    filterText = searchInput.value.trim();
    saveUIState();
    encodeStateToHash();
    renderNotes();
  }
  // Tag filter autocomplete for filter input
  let tagFilterAcIndex = -1;
  function updateTagFilterAutocomplete(){
    const val = tagFilterInput.value.toLowerCase();
    const candidates = [...tagsSet].filter(t => t.toLowerCase().startsWith(val) && val.length > 0);
    tagFilterList.innerHTML = "";
    if(candidates.length === 0){
      tagFilterList.hidden = true;
      tagFilterInput.setAttribute("aria-expanded", "false");
      return;
    }
    candidates.forEach((c,i) => {
      const li = document.createElement("li");
      li.textContent = c;
      li.id = `tag-filter-ac-${i}`;
      li.setAttribute("role", "option");
      li.setAttribute("aria-selected", i === tagFilterAcIndex ? "true" : "false");
      li.addEventListener("mousedown", e => {
        e.preventDefault();
        selectTagFilterAutocomplete(c);
      });
      tagFilterList.appendChild(li);
    });
    tagFilterList.hidden = false;
    tagFilterInput.setAttribute("aria-expanded", "true");
  }
  function selectTagFilterAutocomplete(tag){
    tagFilterInput.value = tag;
    filterTag = tag;
    tagFilterList.hidden = true;
    tagFilterInput.setAttribute("aria-expanded", "false");
    tagFilterInput.focus();
    saveUIState();
    encodeStateToHash();
    renderNotes();
  }
  tagFilterInput.addEventListener("input", e => {
    tagFilterAcIndex = -1;
    updateTagFilterAutocomplete();
  });
  tagFilterInput.addEventListener("keydown", e => {
    if(tagFilterList.hidden) return;
    const items = tagFilterList.querySelectorAll("li");
    if(e.key === "ArrowDown"){
      e.preventDefault();
      tagFilterAcIndex = (tagFilterAcIndex + 1) % items.length;
      updateTagFilterAriaSelected();
    } else if(e.key === "ArrowUp"){
      e.preventDefault();
      tagFilterAcIndex = (tagFilterAcIndex - 1 + items.length) % items.length;
      updateTagFilterAriaSelected();
    } else if(e.key === "Enter"){
      if(tagFilterAcIndex >= 0 && tagFilterAcIndex < items.length){
        e.preventDefault();
        selectTagFilterAutocomplete(items[tagFilterAcIndex].textContent);
      } else {
        filterTag = tagFilterInput.value.trim();
        tagFilterList.hidden = true;
        tagFilterInput.setAttribute("aria-expanded", "false");
        saveUIState();
        encodeStateToHash();
        renderNotes();
      }
    } else if(e.key === "Escape"){
      tagFilterList.hidden = true;
      tagFilterInput.setAttribute("aria-expanded", "false");
      tagFilterAcIndex = -1;
    }
    function updateTagFilterAriaSelected(){
      items.forEach((li,i) => {
        li.setAttribute("aria-selected", i === tagFilterAcIndex ? "true" : "false");
      });
    }
  });
  tagFilterInput.addEventListener("blur", e => {
    setTimeout(() => {
      tagFilterList.hidden = true;
      tagFilterInput.setAttribute("aria-expanded", "false");
      tagFilterAcIndex = -1;
    }, 150);
  });
  tagFilterInput.addEventListener("change", e => {
    filterTag = tagFilterInput.value.trim();
    saveUIState();
    encodeStateToHash();
    renderNotes();
  });

  // Sort select handler
  function onSortChange(){
    sortOrder = sortSelect.value;
    saveUIState();
    encodeStateToHash();
    renderNotes();
  }

  // Keyboard shortcuts
  function onKeyDown(e){
    if(e.ctrlKey && !e.shiftKey && !e.altKey){
      if(e.key.toLowerCase() === "n"){
        e.preventDefault();
        addNoteBtn.click();
      } else if(e.key.toLowerCase() === "f"){
        e.preventDefault();
        searchInput.focus();
      }
    }
    if(e.key === "Delete" && selectedNoteId){
      const focused = document.activeElement;
      if(focused && (focused.tagName === "TEXTAREA" || focused.tagName === "INPUT")) return;
      e.preventDefault();
      deleteNote(selectedNoteId);
    }
  }

  // Initialization
  function init(){
    loadNotes();
    updateTagsSet();
    loadUIState();
    decodeStateFromHash();

    // Apply UI state to inputs
    searchInput.value = filterText;
    tagFilterInput.value = filterTag;
    sortSelect.value = sortOrder;

    renderNotes();

    // Event listeners
    addNoteBtn.addEventListener("click", addNote);
    searchInput.addEventListener("input", onSearchInput);
    sortSelect.addEventListener("change", onSortChange);
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("hashchange", () => {
      decodeStateFromHash();
      searchInput.value = filterText;
      tagFilterInput.value = filterTag;
      sortSelect.value = sortOrder;
      renderNotes();
    });
  }

  // Accessibility helper: visually hidden class for screen reader only text
  const style = document.createElement("style");
  style.textContent = ".sr-only {position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0;}";
  document.head.appendChild(style);

  init();
})();  
</script>
</body>
</html>