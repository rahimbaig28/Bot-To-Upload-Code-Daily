<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-10-29T16:53:22.443390Z -->

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Research Clipboard Grid</title>
<style>
  :root {
    --bg: #f9f9f9;
    --card-bg: #fff;
    --card-border: #ccc;
    --focus-outline: #005fcc;
    --text-color: #222;
    --accent-color: #007acc;
    --tag-bg: #e0f0ff;
    --tag-color: #005a9e;
    --shadow: rgba(0,0,0,0.1);
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; font-family: system-ui, sans-serif; background: var(--bg); color: var(--text-color);
    display: flex; flex-direction: column; min-height: 100vh;
  }
  header {
    background: var(--card-bg);
    padding: 0.5rem 1rem;
    border-bottom: 1px solid var(--card-border);
    display: flex; align-items: center; gap: 0.5rem;
  }
  label[for="search"] {
    font-weight: 600;
  }
  input#search {
    flex-grow: 1;
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid var(--card-border);
    border-radius: 4px;
  }
  input#search:focus {
    outline: 2px solid var(--focus-outline);
    border-color: var(--focus-outline);
  }
  main {
    flex-grow: 1;
    padding: 1rem;
    overflow-y: auto;
  }
  #grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(280px,1fr));
    gap: 1rem;
  }
  .card {
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 6px;
    box-shadow: 0 1px 3px var(--shadow);
    display: flex;
    flex-direction: column;
    padding: 0.75rem 1rem;
    position: relative;
  }
  .card[aria-expanded="true"] .content {
    white-space: normal;
    max-height: none;
  }
  .card[aria-expanded="false"] .content {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-height: 1.5em;
  }
  .content {
    cursor: text;
    user-select: text;
    margin-bottom: 0.5rem;
    max-height: 1.5em;
    transition: max-height 0.3s ease;
  }
  .annotation, .tags {
    font-size: 0.85rem;
    color: #555;
    border: none;
    background: var(--bg);
    resize: none;
    width: 100%;
    font-family: inherit;
    padding: 0.15rem 0.25rem;
    border-radius: 3px;
  }
  .annotation:focus, .tags:focus {
    outline: 2px solid var(--focus-outline);
    background: #fff;
  }
  .tags {
    margin-top: 0.3rem;
    color: var(--tag-color);
    background: var(--tag-bg);
  }
  .card:focus-within {
    outline: 2px solid var(--focus-outline);
    outline-offset: 2px;
  }
  .card[draggable="true"] {
    cursor: grab;
  }
  .card.dragging {
    opacity: 0.6;
    cursor: grabbing;
  }
  .card .actions {
    margin-top: auto;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  }
  button.action-btn {
    background: none;
    border: none;
    color: var(--accent-color);
    cursor: pointer;
    font-size: 1rem;
    padding: 0;
  }
  button.action-btn:focus {
    outline: 2px solid var(--focus-outline);
    outline-offset: 2px;
  }
  #modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.3);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }
  #modal-overlay.active {
    display: flex;
  }
  #modal {
    background: var(--card-bg);
    border-radius: 8px;
    max-width: 90vw;
    max-height: 90vh;
    width: 480px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
  }
  #modal textarea {
    flex-grow: 1;
    font-family: monospace, monospace;
    font-size: 0.9rem;
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    border-radius: 4px;
    resize: vertical;
  }
  #modal textarea:focus {
    outline: 2px solid var(--focus-outline);
  }
  #modal .modal-actions {
    margin-top: 0.75rem;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  }
  #modal button {
    padding: 0.4rem 0.75rem;
    border-radius: 4px;
    border: 1px solid var(--accent-color);
    background: var(--accent-color);
    color: white;
    font-weight: 600;
    cursor: pointer;
  }
  #modal button:focus {
    outline: 2px solid var(--focus-outline);
  }
  #modal button.secondary {
    background: transparent;
    color: var(--accent-color);
  }
  @media (hover: hover) {
    .card:hover {
      box-shadow: 0 4px 8px var(--shadow);
    }
  }
</style>
</head>
<body>
<header role="banner">
  <label for="search" id="search-label">Search Clips:</label>
  <input type="search" id="search" aria-labelledby="search-label" placeholder="Filter by text or tags" autocomplete="off" />
  <button id="exportBtn" aria-label="Export clips as JSON" title="Export clips (Ctrl+E)">‚¨áÔ∏è</button>
  <button id="importBtn" aria-label="Import clips from JSON" title="Import clips (Ctrl+I)">‚¨ÜÔ∏è</button>
</header>
<main role="main" tabindex="0">
  <div id="grid" role="list" aria-live="polite" aria-label="Research clips grid"></div>
</main>

<div id="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="modal-title" tabindex="-1">
  <div id="modal">
    <h2 id="modal-title">Import / Export Clips JSON</h2>
    <textarea id="modal-textarea" aria-describedby="modal-desc" spellcheck="false" rows="10"></textarea>
    <div id="modal-desc" style="font-size:0.85rem; color:#666; margin-top:0.3rem;">
      Paste JSON to import or copy JSON to export your clips.
    </div>
    <div class="modal-actions">
      <button id="modal-import" class="secondary">Import</button>
      <button id="modal-copy">Copy</button>
      <button id="modal-close">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // Data structure for clips:
  // { id: string, content: string, annotation: string, tags: string, order: number }

  const STORAGE_KEY = 'researchClipboardGridClips';

  const grid = document.getElementById('grid');
  const searchInput = document.getElementById('search');
  const modalOverlay = document.getElementById('modal-overlay');
  const modalTextarea = document.getElementById('modal-textarea');
  const modalImportBtn = document.getElementById('modal-import');
  const modalCopyBtn = document.getElementById('modal-copy');
  const modalCloseBtn = document.getElementById('modal-close');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');

  let clips = [];
  let dragSrcEl = null;
  let keyboardMovingCard = null;

  // Utility: generate unique ID
  function genId() {
    return 'clip-' + Math.random().toString(36).slice(2, 10);
  }

  // Save clips to localStorage
  function saveClips() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(clips));
  }

  // Load clips from localStorage
  function loadClips() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          clips = arr;
          clips.sort((a,b) => a.order - b.order);
        }
      }
    } catch {
      clips = [];
    }
  }

  // Sanitize text for display (basic)
  function sanitize(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Create a card element for a clip
  function createCard(clip) {
    const card = document.createElement('article');
    card.className = 'card';
    card.setAttribute('role', 'listitem');
    card.setAttribute('tabindex', '0');
    card.setAttribute('aria-expanded', 'false');
    card.setAttribute('draggable', 'true');
    card.dataset.id = clip.id;

    // Content container (click to toggle expand)
    const contentDiv = document.createElement('div');
    contentDiv.className = 'content';
    contentDiv.textContent = clip.content;
    contentDiv.setAttribute('tabindex', '-1');
    contentDiv.setAttribute('aria-label', 'Clipped content');
    card.appendChild(contentDiv);

    // Annotation textarea
    const annotation = document.createElement('textarea');
    annotation.className = 'annotation';
    annotation.setAttribute('aria-label', 'Annotation for clip');
    annotation.value = clip.annotation || '';
    annotation.rows = 1;
    annotation.placeholder = 'Add annotation...';
    annotation.spellcheck = false;
    card.appendChild(annotation);

    // Tags input (single line)
    const tags = document.createElement('input');
    tags.type = 'text';
    tags.className = 'tags';
    tags.setAttribute('aria-label', 'Tags for clip, comma separated');
    tags.value = clip.tags || '';
    tags.placeholder = 'Tags (comma separated)';
    card.appendChild(tags);

    // Actions container with delete button
    const actions = document.createElement('div');
    actions.className = 'actions';

    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'action-btn';
    deleteBtn.textContent = 'üóëÔ∏è';
    deleteBtn.title = 'Delete clip (Del)';
    deleteBtn.setAttribute('aria-label', 'Delete clip');
    actions.appendChild(deleteBtn);

    card.appendChild(actions);

    // Event listeners

    // Toggle expand/collapse on content click or Enter/Space when focused
    contentDiv.addEventListener('click', () => {
      toggleExpand(card);
    });
    contentDiv.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleExpand(card);
      }
    });

    // Adjust annotation height dynamically
    annotation.addEventListener('input', () => {
      annotation.style.height = 'auto';
      annotation.style.height = annotation.scrollHeight + 'px';
      updateClipAnnotation(clip.id, annotation.value);
    });
    // Initialize height
    annotation.style.height = 'auto';
    annotation.style.height = annotation.scrollHeight + 'px';

    // Update annotation on blur or input
    annotation.addEventListener('blur', () => {
      updateClipAnnotation(clip.id, annotation.value);
    });

    // Update tags on blur or input
    tags.addEventListener('input', () => {
      updateClipTags(clip.id, tags.value);
    });
    tags.addEventListener('blur', () => {
      updateClipTags(clip.id, tags.value);
    });

    // Delete clip
    deleteBtn.addEventListener('click', () => {
      deleteClip(clip.id);
    });

    // Keyboard delete on card when focused
    card.addEventListener('keydown', e => {
      if (e.key === 'Delete') {
        e.preventDefault();
        deleteClip(clip.id);
      }
      // Keyboard reorder: Ctrl + Arrow Up/Down
      if ((e.ctrlKey || e.metaKey) && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        e.preventDefault();
        moveClipByKey(clip.id, e.key === 'ArrowUp' ? -1 : 1);
      }
    });

    // Drag and drop handlers
    card.addEventListener('dragstart', dragStart);
    card.addEventListener('dragover', dragOver);
    card.addEventListener('drop', drop);
    card.addEventListener('dragend', dragEnd);

    return card;
  }

  // Toggle expand/collapse of card content
  function toggleExpand(card) {
    const expanded = card.getAttribute('aria-expanded') === 'true';
    card.setAttribute('aria-expanded', expanded ? 'false' : 'true');
  }

  // Update annotation in data and save
  function updateClipAnnotation(id, text) {
    const clip = clips.find(c => c.id === id);
    if (clip) {
      clip.annotation = text.trim();
      saveClips();
    }
  }
  // Update tags in data and save
  function updateClipTags(id, text) {
    const clip = clips.find(c => c.id === id);
    if (clip) {
      clip.tags = text.trim();
      saveClips();
    }
  }

  // Delete clip by id
  function deleteClip(id) {
    const idx = clips.findIndex(c => c.id === id);
    if (idx !== -1) {
      clips.splice(idx, 1);
      saveClips();
      renderGrid();
    }
  }

  // Move clip by keyboard reorder (up/down)
  function moveClipByKey(id, direction) {
    const idx = clips.findIndex(c => c.id === id);
    if (idx === -1) return;
    const newIndex = idx + direction;
    if (newIndex < 0 || newIndex >= clips.length) return;
    // Swap order values
    [clips[idx].order, clips[newIndex].order] = [clips[newIndex].order, clips[idx].order];
    clips.sort((a,b) => a.order - b.order);
    saveClips();
    renderGrid();
    // Focus moved card
    setTimeout(() => {
      const card = grid.querySelector(`[data-id="${id}"]`);
      if (card) card.focus();
    }, 0);
  }

  // Drag and drop handlers
  function dragStart(e) {
    dragSrcEl = e.currentTarget;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', dragSrcEl.dataset.id);
    dragSrcEl.classList.add('dragging');
  }
  function dragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const target = e.currentTarget;
    if (target && target !== dragSrcEl && target.classList.contains('card')) {
      const rect = target.getBoundingClientRect();
      const next = (e.clientY - rect.top) / rect.height > 0.5;
      grid.insertBefore(dragSrcEl, next ? target.nextSibling : target);
    }
  }
  function drop(e) {
    e.preventDefault();
    const id = e.dataTransfer.getData('text/plain');
    if (!id) return;
    reorderByDom();
  }
  function dragEnd(e) {
    if (dragSrcEl) dragSrcEl.classList.remove('dragging');
    dragSrcEl = null;
  }

  // Reorder clips array based on DOM order
  function reorderByDom() {
    const newOrder = [];
    grid.querySelectorAll('.card').forEach((card, i) => {
      const id = card.dataset.id;
      const clip = clips.find(c => c.id === id);
      if (clip) {
        clip.order = i;
        newOrder.push(clip);
      }
    });
    clips = newOrder;
    saveClips();
    renderGrid();
  }

  // Render grid with filtering
  function renderGrid() {
    const filter = searchInput.value.trim().toLowerCase();
    grid.innerHTML = '';
    clips.forEach(clip => {
      if (filter) {
        const haystack = (clip.content + ' ' + (clip.annotation || '') + ' ' + (clip.tags || '')).toLowerCase();
        if (!haystack.includes(filter)) return;
      }
      const card = createCard(clip);
      grid.appendChild(card);
    });
  }

  // Add new clip from clipboard text or URL
  async function addClipFromClipboard() {
    try {
      let text = '';
      if (navigator.clipboard && navigator.clipboard.readText) {
        text = await navigator.clipboard.readText();
      } else {
        // fallback prompt
        text = prompt('Paste clipboard text here:') || '';
      }
      if (!text.trim()) return;
      const id = genId();
      const maxOrder = clips.length ? Math.max(...clips.map(c => c.order)) : -1;
      clips.push({id, content: text.trim(), annotation: '', tags: '', order: maxOrder + 1});
      saveClips();
      renderGrid();
      // Focus new card
      setTimeout(() => {
        const card = grid.querySelector(`[data-id="${id}"]`);
        if (card) card.focus();
      }, 0);
    } catch (e) {
      alert('Failed to read clipboard: ' + e.message);
    }
  }

  // Keyboard shortcuts handler
  function onKeyDown(e) {
    // Ctrl+Shift+V to add clip from clipboard
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'v') {
      e.preventDefault();
      addClipFromClipboard();
      return;
    }
    // Ctrl+E to open export modal
    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'e') {
      e.preventDefault();
      openModal('export');
      return;
    }
    // Ctrl+I to open import modal
    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'i') {
      e.preventDefault();
      openModal('import');
      return;
    }
  }

  // Modal logic
  let modalMode = 'export'; // or 'import'

  function openModal(mode) {
    modalMode = mode;
    if (mode === 'export') {
      modalTextarea.value = JSON.stringify(clips, null, 2);
      modalTextarea.readOnly = true;
      modalImportBtn.style.display = 'none';
      modalCopyBtn.style.display = '';
      modalTextarea.select();
    } else {
      modalTextarea.value = '';
      modalTextarea.readOnly = false;
      modalImportBtn.style.display = '';
      modalCopyBtn.style.display = 'none';
      modalTextarea.focus();
    }
    modalOverlay.classList.add('active');
    modalOverlay.focus();
  }
  function closeModal() {
    modalOverlay.classList.remove('active');
  }

  modalCloseBtn.addEventListener('click', closeModal);
  modalOverlay.addEventListener('click', e => {
    if (e.target === modalOverlay) closeModal();
  });
  modalOverlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      e.preventDefault();
      closeModal();
    }
  });

  modalCopyBtn.addEventListener('click', () => {
    modalTextarea.select();
    document.execCommand('copy');
  });

  modalImportBtn.addEventListener('click', () => {
    try {
      const imported = JSON.parse(modalTextarea.value);
      if (!Array.isArray(imported)) throw new Error('Invalid JSON structure');
      // Validate minimal structure
      for (const c of imported) {
        if (typeof c.id !== 'string' || typeof c.content !== 'string') {
          throw new Error('Invalid clip format');
        }
      }
      clips = imported;
      clips.sort((a,b) => a.order - b.order);
      saveClips();
      renderGrid();
      closeModal();
    } catch (err) {
      alert('Import failed: ' + err.message);
    }
  });

  // Search input event
  searchInput.addEventListener('input', () => {
    renderGrid();
  });

  // Export/import buttons
  exportBtn.addEventListener('click', () => openModal('export'));
  importBtn.addEventListener('click', () => openModal('import'));

  // Initialization
  loadClips();
  renderGrid();
  window.addEventListener('keydown', onKeyDown);

  // Accessibility: focus outlines visible by default, no special handling needed

  // Touch drag support: native draggable attribute suffices on mobile

})();
</script>
</body>
</html>